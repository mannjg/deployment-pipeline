# Reset Script MR Workflow Refactor

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Refactor reset-demo-state.sh to use MR-based workflow instead of direct GitLab API modifications, ensuring manifests are properly regenerated by Jenkins.

**Architecture:** Replace Phase 3's direct file modifications with feature branch → MR → merge workflow for each environment. This dogfoods our own CI/CD workflow and ensures Jenkins regenerates manifests (which it skips on direct env branch commits).

**Tech Stack:** Bash, GitLab API (via gitlab-cli.sh), Jenkins, existing pipeline-wait.sh library functions

---

## Background

### The Problem

The reset script directly modifies files on environment branches (dev, stage, prod) via GitLab API. This bypasses the normal CI/CD workflow:

1. Direct commits to env branches trigger Jenkins builds
2. But Jenkins **skips manifest generation** on env branches (by design - to prevent feedback loops)
3. Result: CUE config is reset but manifests remain stale

### The Solution

Use the same workflow as normal development:
1. Create feature branch from env branch
2. Make changes on feature branch
3. Create MR to env branch
4. Jenkins runs on feature branch and regenerates manifests
5. Merge MR (manifests arrive via merge)

### Key Design Decisions

1. **One feature branch per environment** - Resets dev, stage, prod independently
2. **Parallel execution** - All three MRs can be created and processed in parallel
3. **Use existing helpers** - pipeline-wait.sh already has `create_mr`, `wait_for_mr_pipeline`, `accept_mr`
4. **Branch naming** - `reset-demo-{env}-{timestamp}` pattern (matches cleanup patterns)
5. **Auto-merge with [no-promote]** - Prevents cascading promotion MRs during reset

---

## Task 1: Create Shared MR Workflow Library

**Files:**
- Create: `scripts/lib/mr-workflow.sh`

**Step 1: Create the library file with MR workflow functions**

```bash
#!/bin/bash
# mr-workflow.sh - MR-based workflow helpers for operational scripts
#
# Provides high-level functions for the MR workflow pattern:
#   create feature branch → make changes → create MR → wait for CI → merge
#
# Source this file: source "$SCRIPT_DIR/../lib/mr-workflow.sh"
#
# Prerequisites:
#   - config/infra.env sourced
#   - GITLAB_TOKEN, JENKINS_USER, JENKINS_TOKEN set

set -euo pipefail

MR_WORKFLOW_LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load dependencies
source "$MR_WORKFLOW_LIB_DIR/infra.sh"
source "$MR_WORKFLOW_LIB_DIR/credentials.sh"

# ============================================================================
# CONFIGURATION
# ============================================================================

MR_WORKFLOW_TIMEOUT="${MR_WORKFLOW_TIMEOUT:-300}"
MR_WORKFLOW_POLL_INTERVAL="${MR_WORKFLOW_POLL_INTERVAL:-10}"

# ============================================================================
# INTERNAL HELPERS
# ============================================================================

_mw_encode_project() {
    echo "$1" | sed 's/\//%2F/g'
}

_mw_encode_path() {
    echo "$1" | sed 's/\//%2F/g'
}

# ============================================================================
# BRANCH OPERATIONS
# ============================================================================

# Create a feature branch from a base branch
# Usage: mw_create_branch <project> <branch_name> <base_branch>
# Returns: 0 on success, 1 on failure
mw_create_branch() {
    local project="$1"
    local branch_name="$2"
    local base_branch="$3"

    local gitlab_cli="$MR_WORKFLOW_LIB_DIR/../04-operations/gitlab-cli.sh"

    if "$gitlab_cli" branch create "$project" "$branch_name" --from "$base_branch" >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Delete a branch
# Usage: mw_delete_branch <project> <branch_name>
mw_delete_branch() {
    local project="$1"
    local branch_name="$2"

    local gitlab_cli="$MR_WORKFLOW_LIB_DIR/../04-operations/gitlab-cli.sh"
    "$gitlab_cli" branch delete "$project" "$branch_name" >/dev/null 2>&1 || true
}

# ============================================================================
# FILE OPERATIONS
# ============================================================================

# Commit multiple files to a branch in a single commit
# Usage: mw_commit_files <project> <branch> <commit_message> <file1:content1> [file2:content2] ...
# File content can be passed as base64 by prefixing with "base64:"
# Returns: 0 on success, 1 on failure
mw_commit_files() {
    local project="$1"
    local branch="$2"
    local commit_message="$3"
    shift 3

    local encoded_project=$(_mw_encode_project "$project")
    local gitlab_url="${GITLAB_URL_EXTERNAL:-https://gitlab.jmann.local}"
    local gitlab_token="${GITLAB_TOKEN}"

    # Build actions array
    local actions="["
    local first=true

    for file_spec in "$@"; do
        local file_path="${file_spec%%:*}"
        local content="${file_spec#*:}"

        # Check if content is base64 encoded
        local encoding="text"
        if [[ "$content" == base64:* ]]; then
            content="${content#base64:}"
            encoding="base64"
        fi

        # Check if file exists to determine action
        local encoded_path=$(_mw_encode_path "$file_path")
        local file_check=$(curl -sk -H "PRIVATE-TOKEN: $gitlab_token" \
            "$gitlab_url/api/v4/projects/$encoded_project/repository/files/$encoded_path?ref=$branch" 2>/dev/null)

        local action="create"
        if echo "$file_check" | jq -e '.file_name' >/dev/null 2>&1; then
            action="update"
        fi

        [[ "$first" == "true" ]] || actions+=","
        first=false

        # Escape content for JSON
        local escaped_content=$(echo "$content" | jq -Rs '.')

        actions+="{\"action\":\"$action\",\"file_path\":\"$file_path\",\"content\":$escaped_content,\"encoding\":\"$encoding\"}"
    done

    actions+="]"

    # Create commit
    local payload=$(jq -n \
        --arg branch "$branch" \
        --arg message "$commit_message" \
        --argjson actions "$actions" \
        '{branch: $branch, commit_message: $message, actions: $actions}')

    local result=$(curl -sk -X POST -H "PRIVATE-TOKEN: $gitlab_token" \
        -H "Content-Type: application/json" \
        -d "$payload" \
        "$gitlab_url/api/v4/projects/$encoded_project/repository/commits" 2>/dev/null)

    if echo "$result" | jq -e '.id' >/dev/null 2>&1; then
        return 0
    else
        echo "Commit failed: $(echo "$result" | jq -r '.message // .error // "Unknown error"')" >&2
        return 1
    fi
}

# Get file content from a branch
# Usage: mw_get_file <project> <branch> <file_path>
# Returns: File content on stdout
mw_get_file() {
    local project="$1"
    local branch="$2"
    local file_path="$3"

    local gitlab_cli="$MR_WORKFLOW_LIB_DIR/../04-operations/gitlab-cli.sh"
    "$gitlab_cli" file get "$project" "$file_path" --ref "$branch" 2>/dev/null
}

# ============================================================================
# MR OPERATIONS
# ============================================================================

# Create an MR
# Usage: mw_create_mr <project> <source_branch> <target_branch> <title>
# Returns: MR IID on stdout, 0 on success, 1 on failure
mw_create_mr() {
    local project="$1"
    local source_branch="$2"
    local target_branch="$3"
    local title="$4"

    local encoded_project=$(_mw_encode_project "$project")
    local gitlab_url="${GITLAB_URL_EXTERNAL:-https://gitlab.jmann.local}"
    local gitlab_token="${GITLAB_TOKEN}"

    local response=$(curl -sk -X POST \
        -H "PRIVATE-TOKEN: $gitlab_token" \
        -H "Content-Type: application/json" \
        -d "{\"source_branch\":\"$source_branch\",\"target_branch\":\"$target_branch\",\"title\":\"$title\"}" \
        "$gitlab_url/api/v4/projects/$encoded_project/merge_requests" 2>/dev/null)

    local mr_iid=$(echo "$response" | jq -r '.iid // empty')

    if [[ -n "$mr_iid" ]]; then
        echo "$mr_iid"
        return 0
    else
        echo "MR creation failed: $(echo "$response" | jq -r '.message // .error // "Unknown error"')" >&2
        return 1
    fi
}

# Wait for MR pipeline (Jenkins CI) to complete
# Usage: mw_wait_for_mr_pipeline <project> <mr_iid> [timeout]
# Returns: 0 if passed, 1 if failed or timeout
mw_wait_for_mr_pipeline() {
    local project="$1"
    local mr_iid="$2"
    local timeout="${3:-$MR_WORKFLOW_TIMEOUT}"

    local encoded_project=$(_mw_encode_project "$project")
    local gitlab_url="${GITLAB_URL_EXTERNAL:-https://gitlab.jmann.local}"
    local gitlab_token="${GITLAB_TOKEN}"
    local jenkins_url="${JENKINS_URL_EXTERNAL:-https://jenkins.jmann.local}"
    local jenkins_user="${JENKINS_USER}"
    local jenkins_token="${JENKINS_TOKEN}"

    # Trigger Jenkins scan to discover the branch
    curl -sk -X POST -u "$jenkins_user:$jenkins_token" \
        "$jenkins_url/job/k8s-deployments/build?delay=0sec" >/dev/null 2>&1 || true

    local poll_interval="${MR_WORKFLOW_POLL_INTERVAL}"
    local elapsed=0

    while [[ $elapsed -lt $timeout ]]; do
        local mr_info=$(curl -sk -H "PRIVATE-TOKEN: $gitlab_token" \
            "$gitlab_url/api/v4/projects/$encoded_project/merge_requests/$mr_iid" 2>/dev/null)

        local pipeline_status=$(echo "$mr_info" | jq -r '.head_pipeline.status // empty')

        case "$pipeline_status" in
            success)
                return 0
                ;;
            failed)
                return 1
                ;;
        esac

        sleep $poll_interval
        elapsed=$((elapsed + poll_interval))
    done

    return 1  # Timeout
}

# Merge an MR
# Usage: mw_merge_mr <project> <mr_iid>
# Returns: 0 on success, 1 on failure
mw_merge_mr() {
    local project="$1"
    local mr_iid="$2"

    local gitlab_cli="$MR_WORKFLOW_LIB_DIR/../04-operations/gitlab-cli.sh"

    if "$gitlab_cli" mr merge "$project" "$mr_iid" >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# ============================================================================
# HIGH-LEVEL WORKFLOW
# ============================================================================

# Complete MR workflow: create branch → commit files → create MR → wait → merge
# Usage: mw_complete_mr_workflow <project> <base_branch> <branch_name> <title> <commit_message> <file1:content1> ...
# Returns: 0 on success, 1 on failure
# Sets: MW_RESULT_MR_IID, MW_RESULT_BRANCH
mw_complete_mr_workflow() {
    local project="$1"
    local base_branch="$2"
    local branch_name="$3"
    local title="$4"
    local commit_message="$5"
    shift 5

    MW_RESULT_MR_IID=""
    MW_RESULT_BRANCH="$branch_name"

    # Step 1: Create feature branch
    if ! mw_create_branch "$project" "$branch_name" "$base_branch"; then
        echo "Failed to create branch $branch_name" >&2
        return 1
    fi

    # Step 2: Commit files
    if ! mw_commit_files "$project" "$branch_name" "$commit_message" "$@"; then
        echo "Failed to commit files to $branch_name" >&2
        mw_delete_branch "$project" "$branch_name"
        return 1
    fi

    # Step 3: Create MR
    local mr_iid
    if ! mr_iid=$(mw_create_mr "$project" "$branch_name" "$base_branch" "$title"); then
        echo "Failed to create MR" >&2
        mw_delete_branch "$project" "$branch_name"
        return 1
    fi
    MW_RESULT_MR_IID="$mr_iid"

    # Step 4: Wait for pipeline
    if ! mw_wait_for_mr_pipeline "$project" "$mr_iid"; then
        echo "Pipeline failed or timed out for MR !$mr_iid" >&2
        return 1
    fi

    # Step 5: Merge
    if ! mw_merge_mr "$project" "$mr_iid"; then
        echo "Failed to merge MR !$mr_iid" >&2
        return 1
    fi

    # Step 6: Cleanup branch (GitLab auto-deletes on merge, but ensure)
    mw_delete_branch "$project" "$branch_name" || true

    return 0
}
```

**Step 2: Verify the library loads without errors**

Run: `bash -n scripts/lib/mr-workflow.sh && echo "Syntax OK"`
Expected: "Syntax OK"

**Step 3: Commit**

```bash
git add scripts/lib/mr-workflow.sh
git commit -m "feat: add MR workflow library for operational scripts

Provides high-level functions for the MR-based workflow pattern:
- mw_create_branch, mw_delete_branch
- mw_commit_files (multi-file atomic commits)
- mw_create_mr, mw_wait_for_mr_pipeline, mw_merge_mr
- mw_complete_mr_workflow (full workflow in one call)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 2: Refactor reset_cue_config to Use MR Workflow

**Files:**
- Modify: `scripts/03-pipelines/reset-demo-state.sh`

**Step 1: Add source for mr-workflow.sh at the top of the file**

Find this line (around line 48-52):
```bash
if [[ -f "$REPO_ROOT/config/infra.env" ]]; then
    source "$REPO_ROOT/config/infra.env"
```

Add after the infra.env source block:
```bash
# Load MR workflow library
source "$SCRIPT_DIR/../lib/mr-workflow.sh"
```

**Step 2: Create new function reset_env_via_mr to replace direct API calls**

Add this new function before `reset_cue_config` (around line 505):

```bash
# =============================================================================
# Phase 3: Reset CUE Configuration via MR Workflow
# =============================================================================

# Reset a single environment using MR workflow
# Usage: reset_env_via_mr <env>
# This creates a feature branch, commits all reset files, creates MR,
# waits for Jenkins to regenerate manifests, and merges.
reset_env_via_mr() {
    local env="$1"
    local timestamp=$(date +%s)
    local branch_name="reset-demo-${env}-${timestamp}"

    log_info ""
    log_info "=== Resetting $env branch via MR workflow ==="

    # 1. Extract current images (to preserve CI/CD-managed values)
    extract_images_from_env_cue "$env"

    # 2. Gather all files to reset
    local files_to_commit=()

    # 2a. Get services/ files from main
    local encoded_project=$(echo "$DEPLOYMENTS_REPO_PATH" | sed 's/\//%2F/g')
    local tree_url="$GITLAB_URL/api/v4/projects/$encoded_project/repository/tree?ref=main&path=services&recursive=true&per_page=100"
    local service_files=$(curl -sk -H "PRIVATE-TOKEN: $GITLAB_TOKEN" "$tree_url" 2>/dev/null | \
        jq -r '.[] | select(.type == "blob") | .path')

    for file_path in $service_files; do
        local content=$(mw_get_file "$DEPLOYMENTS_REPO_PATH" "main" "$file_path")
        if [[ -n "$content" ]]; then
            local content_b64=$(echo "$content" | base64 -w0)
            files_to_commit+=("$file_path:base64:$content_b64")
        fi
    done
    log_info "  Prepared ${#files_to_commit[@]} files from services/"

    # 2b. Get Jenkinsfile from main
    local jenkinsfile_content=$(mw_get_file "$DEPLOYMENTS_REPO_PATH" "main" "Jenkinsfile")
    if [[ -n "$jenkinsfile_content" ]]; then
        local jenkinsfile_b64=$(echo "$jenkinsfile_content" | base64 -w0)
        files_to_commit+=("Jenkinsfile:base64:$jenkinsfile_b64")
        log_info "  Prepared Jenkinsfile"
    fi

    # 2c. Get scripts/ files from main
    tree_url="$GITLAB_URL/api/v4/projects/$encoded_project/repository/tree?ref=main&path=scripts&recursive=true&per_page=100"
    local script_files=$(curl -sk -H "PRIVATE-TOKEN: $GITLAB_TOKEN" "$tree_url" 2>/dev/null | \
        jq -r '.[] | select(.type == "blob") | .path')

    local script_count=0
    for file_path in $script_files; do
        local content=$(mw_get_file "$DEPLOYMENTS_REPO_PATH" "main" "$file_path")
        if [[ -n "$content" ]]; then
            local content_b64=$(echo "$content" | base64 -w0)
            files_to_commit+=("$file_path:base64:$content_b64")
            script_count=$((script_count + 1))
        fi
    done
    log_info "  Prepared $script_count files from scripts/"

    # 2d. Generate env.cue from baseline
    local baseline_file="$BASELINES_DIR/env-${env}.cue"
    if [[ -f "$baseline_file" ]]; then
        local env_cue_content=$(cat "$baseline_file" \
            | sed "s|{{EXAMPLE_APP_IMAGE}}|$EXAMPLE_APP_IMAGE|g" \
            | sed "s|{{POSTGRES_IMAGE}}|$POSTGRES_IMAGE|g")
        local env_cue_b64=$(echo "$env_cue_content" | base64 -w0)
        files_to_commit+=("env.cue:base64:$env_cue_b64")
        log_info "  Prepared env.cue from baseline"
    fi

    # 3. Execute MR workflow
    log_info "  Creating feature branch and MR..."

    local title="chore: reset $env to baseline [no-promote]"
    local commit_message="chore: reset $env CUE configuration to baseline [no-promote]

Resets services/, scripts/, Jenkinsfile, and env.cue from main.
Preserves CI/CD-managed image tags.

Automated reset by reset-demo-state.sh"

    if mw_complete_mr_workflow \
        "$DEPLOYMENTS_REPO_PATH" \
        "$env" \
        "$branch_name" \
        "$title" \
        "$commit_message" \
        "${files_to_commit[@]}"; then
        log_info "  ✓ $env reset complete (MR !$MW_RESULT_MR_IID merged)"
        return 0
    else
        log_error "  ✗ Failed to reset $env via MR workflow"
        return 1
    fi
}
```

**Step 3: Replace reset_cue_config function**

Replace the entire `reset_cue_config` function (lines ~507-576) with:

```bash
# Main Phase 3 function: Reset all CUE configuration via MR workflow
reset_cue_config() {
    log_step "Phase 3: Resetting CUE configuration via MR workflow..."
    log_info ""
    log_info "This uses the standard MR workflow for each environment:"
    log_info "  feature branch → commit changes → MR → Jenkins CI → merge"
    log_info ""

    local failed_envs=()

    for env in dev stage prod; do
        if ! reset_env_via_mr "$env"; then
            failed_envs+=("$env")
        fi
    done

    if [[ ${#failed_envs[@]} -gt 0 ]]; then
        log_error "Failed to reset environments: ${failed_envs[*]}"
        return 1
    fi

    log_info ""
    log_info "CUE configuration reset complete for all environments"
}
```

**Step 4: Remove the old direct-commit helper functions**

Delete these functions (they're no longer needed):
- `reset_services_directory` (lines ~315-358)
- `reset_jenkinsfile` (lines ~361-389)
- `reset_scripts_directory` (lines ~392-444)
- `reset_env_cue_from_baseline` (lines ~447-479)

**Step 5: Verify script syntax**

Run: `bash -n scripts/03-pipelines/reset-demo-state.sh && echo "Syntax OK"`
Expected: "Syntax OK"

**Step 6: Commit**

```bash
git add scripts/03-pipelines/reset-demo-state.sh
git commit -m "refactor: reset-demo-state.sh uses MR workflow instead of direct API

BREAKING: Phase 3 now creates feature branches and MRs for each
environment instead of directly modifying env branches via GitLab API.

This ensures Jenkins regenerates manifests (which it skips on direct
env branch commits) and dogfoods our own CI/CD workflow.

Flow per environment:
1. Create reset-demo-{env}-{timestamp} branch from env
2. Commit all reset files (services/, scripts/, Jenkinsfile, env.cue)
3. Create MR with [no-promote] to prevent cascading promotions
4. Wait for Jenkins CI to regenerate manifests
5. Merge MR
6. Delete feature branch

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 3: Update Cleanup Patterns for New Branch Names

**Files:**
- Modify: `scripts/03-pipelines/reset-demo-state.sh`
- Modify: `scripts/demo/lib/pipeline-state.sh`

**Step 1: Add reset-demo-* to cleanup patterns in reset-demo-state.sh**

Find `cleanup_local_branches` function (around line 174) and update the patterns array:

```bash
    local patterns=("uc-*" "update-dev-*" "promote-*" "sync-main-*" "reset-demo-*")
```

**Step 2: Add reset-demo-* to cleanup_gitlab_orphan_branches patterns**

Find `cleanup_gitlab_orphan_branches` function (around line 198) and update:

```bash
    local patterns=("uc-" "update-dev-" "promote-" "sync-main-" "reset-demo-")
```

**Step 3: Add reset-demo- to pipeline-state.sh lingering branch check**

In `scripts/demo/lib/pipeline-state.sh`, find `_check_lingering_branches` function (around line 137) and update:

```bash
    local patterns=("update-" "promote-" "reset-demo-")
```

**Step 4: Commit**

```bash
git add scripts/03-pipelines/reset-demo-state.sh scripts/demo/lib/pipeline-state.sh
git commit -m "chore: add reset-demo-* to branch cleanup patterns

Ensures reset-demo-{env}-{timestamp} branches are cleaned up by:
- Local branch cleanup in reset-demo-state.sh
- GitLab orphan branch cleanup in reset-demo-state.sh
- Pipeline state checks in demo preflight

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 4: Update CLAUDE.md to Document the Invariant

**Files:**
- Modify: `CLAUDE.md`

**Step 1: Add invariant documentation**

Find the "## Git Remote Strategy (Critical)" section and add a new section after it:

```markdown
## Environment Branch Modification Invariant (Critical)

**Environment branches (dev, stage, prod) are ONLY modified via merged MRs. No exceptions.**

This invariant ensures:
1. Jenkins regenerates manifests (it skips manifest generation on direct env branch commits)
2. All changes are auditable via MR history
3. Operational scripts follow the same workflow as development

**Correct pattern:**
```
feature branch → commit changes → MR to env → Jenkins CI → merge
```

**Incorrect patterns (NEVER do these):**
- Direct GitLab API file modifications to env branches
- Git push directly to env branches
- Any bypass of the MR workflow

The reset-demo-state.sh script follows this pattern by creating MRs for each environment.
```

**Step 2: Commit**

```bash
git add CLAUDE.md
git commit -m "docs: document environment branch modification invariant

Env branches must only be modified via merged MRs to ensure:
- Jenkins regenerates manifests
- Changes are auditable
- Operational scripts dogfood the CI/CD workflow

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 5: Integration Test

**Step 1: Sync changes to GitLab**

Run:
```bash
git push origin main
./scripts/04-operations/sync-to-gitlab.sh
```

**Step 2: Run reset script and verify MR workflow**

Run:
```bash
./scripts/03-pipelines/reset-demo-state.sh 2>&1 | tee /tmp/reset-output.txt
```

Expected output should show for each environment:
- "Creating feature branch and MR..."
- "✓ {env} reset complete (MR !{iid} merged)"

**Step 3: Verify manifests are consistent with CUE**

Run:
```bash
# Check that dev manifest has runAsNonRoot commented (empty securityContext)
./scripts/04-operations/gitlab-cli.sh file get p2c/k8s-deployments manifests/exampleApp/exampleApp.yaml --ref dev 2>/dev/null | grep -A2 "securityContext:"
```

Expected: Both `securityContext: {}` entries (container and pod level), NOT `runAsNonRoot: true`

**Step 4: Run UC-C2 demo to verify end-to-end**

Run:
```bash
./scripts/demo/demo-uc-c2-security-context.sh
```

Expected: Demo completes successfully, showing manifests contain `runAsNonRoot` after the CUE change.

**Step 5: Commit any adjustments**

If tests pass, no commit needed. If adjustments required, commit with:
```bash
git add -A
git commit -m "fix: adjustments from integration testing

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Verification Checklist

After completing all tasks, verify:

- [ ] `scripts/lib/mr-workflow.sh` exists and has no syntax errors
- [ ] `reset-demo-state.sh` sources mr-workflow.sh
- [ ] `reset-demo-state.sh` no longer contains direct GitLab API file modification code
- [ ] Reset creates MRs for each environment (visible in GitLab MR history)
- [ ] Manifests are regenerated by Jenkins during reset (securityContext matches CUE)
- [ ] UC-C2 demo passes
- [ ] CLAUDE.md documents the env branch invariant
- [ ] All cleanup patterns include `reset-demo-*`

---

## Rollback Plan

If the new MR workflow causes issues:

1. Revert to previous reset-demo-state.sh: `git revert HEAD~4` (reverts all 4 commits)
2. For immediate fix, the old direct-API approach can be temporarily restored
3. File an issue to investigate the MR workflow failure

However, the MR workflow is the correct long-term solution. Direct API modifications bypass Jenkins manifest generation and should not be used.
