// Production-Ready Jenkinsfile for example-app CI/CD pipeline
// Refactored for maintainability, reliability, and production best practices

def helpers = null

def loadHelpers() {
    if (helpers == null) {
        helpers = load 'Jenkinsfile.helpers.groovy'
    }
    return helpers
}

// Agent image from system environment (set via ConfigMap envFrom).
// System.getenv() is required here because this runs at Groovy parse time,
// before the pipeline environment block is evaluated.
def getAgentImageOrFail(String envVarName = 'JENKINS_AGENT_IMAGE') {
    def agentImage = System.getenv(envVarName)
    if (!agentImage) {
        error "${envVarName} not set - check pipeline-config ConfigMap"
    }
    return agentImage
}

def podTemplateYaml(String agentImage) {
    return """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: pipeline
    image: ${agentImage}
    command:
    - cat
    tty: true
    env:
    - name: DOCKER_HOST
      value: tcp://localhost:2375
    resources:
      requests:
        memory: "1Gi"
        cpu: "500m"
      limits:
        memory: "2Gi"
        cpu: "2000m"
  - name: dind
    image: docker:dind
    securityContext:
      privileged: true
    env:
    - name: DOCKER_TLS_CERTDIR
      value: ""
    args:
    - --insecure-registry=${env.CONTAINER_REGISTRY_EXTERNAL?.replaceAll('^https?://', '')}
    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "2Gi"
        cpu: "1000m"
"""
}

def gitlabStatusContext = 'jenkins/example-app'

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Deploys to an environment by updating image and creating GitLab merge request
 * Used for dev environment (initial deployment from build)
 * @param environment Target environment (dev)
 * @param branchPrefix Prefix for feature branch name
 * @param mrTitle Title for the merge request
 * @param mrDescription Detailed description for the merge request
 */
def deployToEnvironment(String environment, String branchPrefix, String mrTitle, String mrDescription) {
    container('pipeline') {
        script {
            def h = loadHelpers()
            echo "[${environment.toUpperCase()}] Creating environment update and MR..."

            // Write MR description to temp file (multi-line content can break withEnv)
            def mrDescriptionFile = h.tempFilePath('mr-description', '.txt')
            writeFile file: mrDescriptionFile, text: mrDescription

            // Scope Groovy function params as env vars for sh ''' blocks (not global env.*)
            withEnv([
                "DEPLOY_ENV=${environment}",
                "DEPLOY_BRANCH_PREFIX=${branchPrefix}",
                "DEPLOY_MR_TITLE=${mrTitle}"
            ]) {
                withCredentials([
                    usernamePassword(credentialsId: 'gitlab-credentials',
                                      usernameVariable: 'GIT_USERNAME',
                                      passwordVariable: 'GIT_PASSWORD'),
                    string(credentialsId: 'gitlab-api-token-secret', variable: 'GITLAB_TOKEN')
                ]) {
                    // Phase 1: Clone requires global credential helper (repo doesn't exist yet)
                    h.withGitCredentials {
                        sh '''
                            rm -rf k8s-deployments
                            git clone "${DEPLOYMENT_REPO}" k8s-deployments
                        '''
                    }
                    // Phase 2: All subsequent operations use repo-scoped config
                    h.withGitCredentials('k8s-deployments') {
                        sh '''
                            cd k8s-deployments

                            # Fetch and checkout target environment branch
                            git fetch origin "${DEPLOY_ENV}"
                            git checkout "${DEPLOY_ENV}"
                            git pull origin "${DEPLOY_ENV}"

                            # Create feature branch for this update
                            FEATURE_BRANCH="${DEPLOY_BRANCH_PREFIX}-${IMAGE_TAG}"
                            git checkout -b "${FEATURE_BRANCH}"
                        '''

                        // Update environment configuration (L5 + L6 only, no manifest generation)
                        sh '''
                            cd k8s-deployments

                            # L5: Sync app.cue from source repo (if exists)
                            if [ -f "${WORKSPACE}/deployment/app.cue" ]; then
                                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                                echo "Syncing deployment configuration (L5)..."
                                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                                mkdir -p services/apps
                                cp "${WORKSPACE}/deployment/app.cue" "services/apps/${APP_NAME}.cue"
                                echo "✓ Synced services/apps/${APP_NAME}.cue"
                            fi

                            # L6: Update image tag in env.cue
                            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                            echo "Updating image tag (L6)..."
                            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                            ./scripts/update-app-image.sh "${DEPLOY_ENV}" "${APP_NAME}" "${FULL_IMAGE}"
                            echo "✓ Updated ${APP_NAME} image in env.cue"

                            # Stage CUE changes only - k8s-deployments CI will generate manifests
                            git add services/apps/ env.cue 2>/dev/null || git add env.cue

                            # Check if update-app-image.sh and app.cue sync produced any staged changes.
                            # If the image tag already matches (e.g., rebuild of same commit), git add
                            # stages nothing. Skip commit/push/MR to avoid creating empty MRs (JENKINS-18).
                            if git diff --cached --quiet; then
                                echo "No changes vs ${DEPLOY_ENV} - image tag already current. Skipping MR creation."
                                # Marker file: needed because push/MR runs in a separate sh block
                                # and shell variables don't persist across Jenkinsfile sh invocations.
                                touch "${WORKSPACE}/.no-changes-${BUILD_NUMBER}"
                            else
                                # Commit with metadata
                                git commit -m "${DEPLOY_MR_TITLE}

L5/L6 update from application CI/CD pipeline.

Changes:
- Synced services/apps/${APP_NAME}.cue (if changed)
- Updated ${DEPLOY_ENV} environment image to ${IMAGE_TAG}

Note: Manifests will be generated by k8s-deployments CI.

Build: ${BUILD_URL}
Git commit: ${GIT_SHORT_HASH}
Image: ${FULL_IMAGE}"
                            fi
                        '''

                        // Push feature branch and create merge request (skip if no changes - JENKINS-18)
                        sh '''
                            cd k8s-deployments
                            FEATURE_BRANCH="${DEPLOY_BRANCH_PREFIX}-${IMAGE_TAG}"

                            # Skip push and MR if the update block detected no changes.
                            # The marker file is written by the commit block above when
                            # git diff --cached --quiet indicates nothing was staged (JENKINS-18).
                            if [ -f "${WORKSPACE}/.no-changes-${BUILD_NUMBER}" ]; then
                                echo "Skipping push and MR creation - no changes detected."
                                exit 0
                            fi

                            # Delete remote branch if it exists, then push fresh
                            git push origin --delete "${FEATURE_BRANCH}" 2>/dev/null || echo "Branch does not exist remotely"
                            git push -u origin "${FEATURE_BRANCH}"

                            # GitLab API credentials for MR operations
                            export GITLAB_TOKEN="${GITLAB_TOKEN}"
                            export GITLAB_URL_INTERNAL="${GITLAB_URL}"

                            # Close any open MRs superseded by this build (JENKINS-27)
                            ./scripts/close-superseded-mrs.sh \
                                "${DEPLOY_ENV}" \
                                "${DEPLOY_BRANCH_PREFIX}" \
                                "${FEATURE_BRANCH}"

                            # Create MR using GitLab API
                            ./scripts/create-gitlab-mr.sh \
                                "${FEATURE_BRANCH}" \
                                "${DEPLOY_ENV}" \
                                "${DEPLOY_MR_TITLE}" \
                                "$(cat "${WORKSPACE}/.mr-description-${BUILD_NUMBER}.txt")"
                        '''

                        if (fileExists(h.tempFilePath('no-changes'))) {
                            echo "[${environment.toUpperCase()}] No changes detected - MR creation skipped (image tag already current)"
                        } else {
                            echo "[${environment.toUpperCase()}] ✓ MR created successfully: ${branchPrefix}-${env.IMAGE_TAG} → ${environment}"
                        }
                    }
                }
            }
        }
    }
}

// ============================================================================
// PIPELINE DEFINITION
// ============================================================================

// Get agent image from system environment (set via ConfigMap envFrom)
def agentImage = getAgentImageOrFail()

pipeline {
    agent {
        kubernetes {
            yaml podTemplateYaml(agentImage)
        }
    }

    options {
        timestamps()
        ansiColor('xterm')
        timeout(time: 1, unit: 'HOURS')
        buildDiscarder(logRotator(numToKeepStr: '10', daysToKeepStr: '30'))
        disableConcurrentBuilds()
    }

    parameters {
        booleanParam(
            name: 'SKIP_INTEGRATION_TESTS',
            defaultValue: false,
            description: 'Skip integration tests to speed up build'
        )
    }

    environment {
        // Application metadata
        APP_NAME = 'example-app'
        APP_GROUP = "${env.CONTAINER_REGISTRY_PATH_PREFIX ?: ''}"

        // Container registry - use external URL (nodes trust it, no CA changes needed)
        CONTAINER_REGISTRY = "${env.CONTAINER_REGISTRY_EXTERNAL ?: ''}"

        // Maven repository (internal Nexus for artifacts, torn down with demo)
        MAVEN_REPO_URL = "${env.MAVEN_REPO_URL_INTERNAL ?: ''}"

        // Git repositories (from pipeline-config ConfigMap)
        GITLAB_URL = "${env.GITLAB_URL_INTERNAL ?: ''}"
        GITLAB_GROUP = "${env.GITLAB_GROUP ?: ''}"
        DEPLOYMENT_REPO = "${env.DEPLOYMENTS_REPO_URL ?: ''}"

        // Computed image reference
        IMAGE_NAME = "${CONTAINER_REGISTRY}/${APP_GROUP}/${APP_NAME}"
    }

    stages {
        stage('Checkout & Setup') {
            steps {
                checkout scm
                container('pipeline') {
                    script {
                        echo "=== Checkout & Setup ==="

                        // Validate required environment variables from ConfigMap
                        loadHelpers().validateRequiredEnvVars(['JENKINS_AGENT_IMAGE', 'GITLAB_URL_INTERNAL', 'GITLAB_GROUP', 'DEPLOYMENTS_REPO_URL', 'CONTAINER_REGISTRY_EXTERNAL', 'CONTAINER_REGISTRY_PATH_PREFIX'])

                        // Extract version from pom.xml
                        env.APP_VERSION = sh(
                            script: "mvn help:evaluate -Dexpression=project.version -q -DforceStdout",
                            returnStdout: true
                        ).trim()

                        // Generate image tag (version + git hash)
                        env.GIT_SHORT_HASH = sh(
                            script: "git rev-parse --short HEAD",
                            returnStdout: true
                        ).trim()

                        // Capture full commit SHA for GitLab commit status reporting
                        env.GIT_COMMIT_SHA = sh(
                            script: "git rev-parse HEAD",
                            returnStdout: true
                        ).trim()

                        env.IMAGE_TAG = "${env.APP_VERSION}-${env.GIT_SHORT_HASH}"

                        // Validate IMAGE_TAG
                        if (!env.IMAGE_TAG || env.IMAGE_TAG.contains(' ')) {
                            error("Invalid IMAGE_TAG generated: '${env.IMAGE_TAG}'")
                        }

                        env.FULL_IMAGE = "${env.IMAGE_NAME}:${env.IMAGE_TAG}"

                        echo "✓ Application: ${env.APP_NAME} v${env.APP_VERSION}"
                        echo "✓ Git commit: ${env.GIT_SHORT_HASH}"
                        echo "✓ Image tag: ${env.IMAGE_TAG}"
                        echo "✓ Deploy target: ${env.FULL_IMAGE}"

                        // Report "pending" status to GitLab so MR shows pipeline is running
                        loadHelpers().reportGitLabStatus('pending', gitlabStatusContext, env.GIT_COMMIT_SHA, "${env.GITLAB_GROUP}/example-app")
                    }
                }
            }
        }

        stage('Unit Tests') {
            steps {
                container('pipeline') {
                    timeout(time: 15, unit: 'MINUTES') {
                        echo "=== Running Unit Tests ==="
                        sh 'mvn clean test'
                    }
                }
            }
            post {
                always {
                    junit '**/target/surefire-reports/*.xml'
                }
            }
        }

        stage('Integration Tests') {
            when {
                expression { return !params.SKIP_INTEGRATION_TESTS }
            }
            steps {
                container('pipeline') {
                    timeout(time: 20, unit: 'MINUTES') {
                        echo "=== Running Integration Tests ==="
                        sh 'mvn verify -DskipITs=false'
                    }
                }
            }
            post {
                always {
                    junit '**/target/failsafe-reports/*.xml'
                }
            }
        }

        stage('Build & Publish') {
            steps {
                container('pipeline') {
                    script {
                        timeout(time: 30, unit: 'MINUTES') {
                            echo "=== Building and Publishing Artifacts ==="

                            withCredentials([
                                usernamePassword(credentialsId: 'maven-repo-credentials',
                                                usernameVariable: 'MAVEN_REPO_CREDENTIALS_USR',
                                                passwordVariable: 'MAVEN_REPO_CREDENTIALS_PSW'),
                                usernamePassword(credentialsId: 'container-registry-credentials',
                                                usernameVariable: 'CONTAINER_REGISTRY_CREDENTIALS_USR',
                                                passwordVariable: 'CONTAINER_REGISTRY_CREDENTIALS_PSW')
                            ]) {
                                // Deploy Maven artifact first — fails fast on duplicate
                                // release before pushing a Docker image (JENKINS-26)
                                echo "Publishing Maven artifacts to Nexus..."

                            // Determine repository based on version type
                            def repoPath
                            if (env.APP_VERSION.endsWith('-SNAPSHOT')) {
                                repoPath = 'maven-snapshots'
                                echo "Deploying SNAPSHOT version to maven-snapshots repository"
                            } else {
                                repoPath = 'maven-releases'
                                echo "Deploying release version to maven-releases repository"
                            }

                            // Generate scoped Maven settings and deploy in a single shell
                            // block. mktemp + trap ensures cleanup on success, failure,
                            // or abort — no shared /tmp path needed (JENKINS-28).
                            sh """
                                SETTINGS=\$(mktemp --suffix=-maven-settings.xml)
                                trap 'rm -f "\$SETTINGS"' EXIT
                                cat > "\$SETTINGS" <<SETTINGS_EOF
<?xml version="1.0" encoding="UTF-8"?>
<settings>
  <servers>
    <server>
      <id>nexus</id>
      <username>\${MAVEN_REPO_CREDENTIALS_USR}</username>
      <password>\${MAVEN_REPO_CREDENTIALS_PSW}</password>
    </server>
  </servers>
</settings>
SETTINGS_EOF
                                mvn clean deploy -DskipTests \\
                                    -s "\$SETTINGS" \\
                                    -DaltDeploymentRepository=nexus::default::${MAVEN_REPO_URL}/repository/${repoPath}/
                            """
                                echo "✓ Published Maven artifact: ${APP_NAME}-${APP_VERSION}"

                                // Build and push Docker image with Jib (reuses build output)
                                echo "Building and pushing container image..."
                                sh '''
                                    mvn package \
                                        -Dquarkus.container-image.build=true \
                                        -Dquarkus.container-image.push=true \
                                        -Dquarkus.container-image.registry=${CONTAINER_REGISTRY} \
                                        -Dquarkus.container-image.group=${APP_GROUP} \
                                        -Dquarkus.container-image.name=${APP_NAME} \
                                        -Dquarkus.container-image.tag=${IMAGE_TAG} \
                                        -Dquarkus.container-image.insecure=true \
                                        -Dquarkus.container-image.username=${CONTAINER_REGISTRY_CREDENTIALS_USR} \
                                        -Dquarkus.container-image.password=${CONTAINER_REGISTRY_CREDENTIALS_PSW} \
                                        -DsendCredentialsOverHttp=true
                                '''
                                echo "✓ Published container image: ${FULL_IMAGE}"
                            }
                        }
                    }
                }
            }
        }

        stage('Update Dev Environment') {
            when {
                // Only update dev from main branch - feature branches are for MR CI only
                branch 'main'
            }
            steps {
                script {
                    deployToEnvironment(
                        'dev',
                        'update-dev',
                        "Deploy ${env.APP_NAME} to dev: ${env.IMAGE_TAG}",
                        """## Automatic Deployment to Dev

**Application**: ${env.APP_NAME}
**Image Tag**: ${env.IMAGE_TAG}
**Build**: ${env.BUILD_URL}
**Git Commit**: ${env.GIT_SHORT_HASH}

### Changes

This merge request updates the dev environment with the latest build.

**Image**: ${env.FULL_IMAGE}

### Review Checklist

- [ ] Image tag is correct
- [ ] CUE configuration updated (L5/L6)
- [ ] Ready to merge (k8s-deployments CI will generate manifests)

Once merged, k8s-deployments CI will generate manifests and ArgoCD will deploy to dev.

---
*Generated by Jenkins CI/CD Pipeline*"""
                    )
                }
            }
        }

    }

    post {
        success {
            script {
                echo """
=======================================================
✓ PIPELINE COMPLETED SUCCESSFULLY
=======================================================
Application: ${env.APP_NAME}
Version: ${env.APP_VERSION}
Git Commit: ${env.GIT_SHORT_HASH}
Image: ${env.FULL_IMAGE}
Build URL: ${env.BUILD_URL}
=======================================================
"""
                // Report success status to GitLab
                container('pipeline') {
                    loadHelpers().reportGitLabStatus('success', gitlabStatusContext, env.GIT_COMMIT_SHA, "${env.GITLAB_GROUP}/example-app")
                }
            }
        }
        failure {
            script {
                echo """
=======================================================
✗ PIPELINE FAILED
=======================================================
Application: ${env.APP_NAME}
Build URL: ${env.BUILD_URL}
Check logs above for error details
=======================================================
"""
                // Report failure status to GitLab
                container('pipeline') {
                    loadHelpers().reportGitLabStatus('failed', gitlabStatusContext, env.GIT_COMMIT_SHA, "${env.GITLAB_GROUP}/example-app")
                }
            }
        }
        always {
            container('pipeline') {
                script {
                    // Cleanup temporary files and credentials
                    sh '''
                        echo "Performing cleanup..."
                        rm -rf k8s-deployments || true
                        echo "Cleanup completed"
                    '''
                    loadHelpers().cleanupWorkspaceFiles(['.no-changes-*', '.mr-description-*'])
                }
            }
        }
    }
}
