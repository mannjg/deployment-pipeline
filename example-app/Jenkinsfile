// Production-Ready Jenkinsfile for example-app CI/CD pipeline
// Refactored for maintainability, reliability, and production best practices

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Deploys to an environment by updating image and creating GitLab merge request
 * Used for dev environment (initial deployment from build)
 * @param environment Target environment (dev)
 * @param branchPrefix Prefix for feature branch name
 * @param mrTitle Title for the merge request
 * @param mrDescription Detailed description for the merge request
 */
def deployToEnvironment(String environment, String branchPrefix, String mrTitle, String mrDescription) {
    container('maven') {
        script {
            echo "[${environment.toUpperCase()}] Creating environment update and MR..."

            withCredentials([usernamePassword(credentialsId: 'gitlab-credentials',
                                              usernameVariable: 'GIT_USERNAME',
                                              passwordVariable: 'GIT_PASSWORD')]) {
                try {
                    // Setup git credentials (ephemeral, memory-only)
                    sh '''
                        git config --global user.name "Jenkins CI"
                        git config --global user.email "jenkins@local"
                        git config --global credential.helper '!f() { printf "username=%s\\npassword=%s\\n" "${GIT_USERNAME}" "${GIT_PASSWORD}"; }; f'
                    '''

                    // Clone or update deployment repository
                    sh """
                        rm -rf k8s-deployments
                        git clone \${GITLAB_INTERNAL_URL}/\${GITLAB_GROUP}/k8s-deployments.git k8s-deployments
                        cd k8s-deployments

                        # Fetch and checkout target environment branch
                        git fetch origin ${environment}
                        git checkout ${environment}
                        git pull origin ${environment}

                        # Create feature branch for this update
                        FEATURE_BRANCH="${branchPrefix}-\${IMAGE_TAG}"
                        git checkout -b "\${FEATURE_BRANCH}"
                    """

                    // **NEW: Sync deployment/app.cue from application repo (only for dev)**
                    if (environment == 'dev') {
                        sh """
                            cd k8s-deployments

                            # Ensure target directory exists
                            mkdir -p services/apps

                            # Check if deployment/app.cue exists in application repo
                            if [ -f "\${WORKSPACE}/deployment/app.cue" ]; then
                                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                                echo "Syncing deployment configuration..."
                                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                                echo "Source: \${WORKSPACE}/deployment/app.cue"
                                echo "Target: services/apps/\${APP_NAME}.cue"
                                echo ""

                                # Copy app-specific CUE config from source repo
                                cp \${WORKSPACE}/deployment/app.cue services/apps/\${APP_NAME}.cue

                                # Validate the synced CUE file
                                echo "Validating synced configuration..."
                                if command -v cue &> /dev/null; then
                                    if cue vet -c=false ./services/apps/\${APP_NAME}.cue; then
                                        echo "✓ Synced configuration is valid"
                                    else
                                        echo "✗ ERROR: Synced configuration validation failed!"
                                        exit 1
                                    fi
                                else
                                    echo "⚠ WARNING: cue command not found, skipping validation"
                                fi

                                # Show what changed in the deployment config
                                echo ""
                                if git diff --quiet services/apps/\${APP_NAME}.cue; then
                                    echo "  No changes in deployment configuration"
                                else
                                    echo "Configuration changes:"
                                    git diff services/apps/\${APP_NAME}.cue | head -50
                                fi
                                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                            else
                                echo "⚠ WARNING: No deployment/app.cue found in application repository"
                                echo "           Skipping config sync (application may not have deployment config)"
                            fi
                        """
                    }

                    // Update environment configuration and generate manifests
                    sh """
                        cd k8s-deployments

                        # Update image reference in environment CUE file (app-specific)
                        # This script ensures only the specified app's image is updated
                        ./scripts/update-app-image.sh ${environment} ${APP_NAME} "${IMAGE_FOR_DEPLOY}"

                        echo "[${environment.toUpperCase()}] Updated ${APP_NAME} image in env.cue"

                        # Generate Kubernetes manifests from CUE configuration
                        ./scripts/generate-manifests.sh ${environment}

                        # Stage all changes (synced config + CUE file + generated manifests)
                        git add services/apps/ env.cue manifests/ 2>/dev/null || git add env.cue manifests/

                        # Commit with metadata
                        COMMIT_MSG="${mrTitle}

Automated deployment update from application CI/CD pipeline.

Changes:"

                        # Add sync info for dev environment
                        if [ "${environment}" = "dev" ]; then
                            if [ -f "services/apps/\${APP_NAME}.cue" ]; then
                                COMMIT_MSG="\${COMMIT_MSG}
- Synced services/apps/\${APP_NAME}.cue from source repository"
                            fi
                        fi

                        COMMIT_MSG="\${COMMIT_MSG}
- Updated ${environment} environment image to \${IMAGE_TAG}
- Regenerated Kubernetes manifests

Build: \${BUILD_URL}
Git commit: \${GIT_SHORT_HASH}
Image: \${FULL_IMAGE}
Deploy image: ${IMAGE_FOR_DEPLOY}

Generated manifests from CUE configuration."

                        git commit -m "\${COMMIT_MSG}" || echo "No changes to commit"
                    """

                    // Push feature branch and create merge request
                    sh """
                        cd k8s-deployments
                        FEATURE_BRANCH="${branchPrefix}-\${IMAGE_TAG}"

                        # Delete remote branch if it exists, then push fresh
                        git push origin --delete "\${FEATURE_BRANCH}" 2>/dev/null || echo "Branch does not exist remotely"
                        git push -u origin "\${FEATURE_BRANCH}"

                        # Create MR using GitLab API
                        export GITLAB_TOKEN="${GITLAB_API_TOKEN}"
                        export GITLAB_URL="\${GITLAB_EXTERNAL_URL}"

                        ./scripts/create-gitlab-mr.sh \
                            "\${FEATURE_BRANCH}" \
                            ${environment} \
                            "${mrTitle}" \
                            "${mrDescription}"
                    """

                    echo "[${environment.toUpperCase()}] ✓ MR created successfully: ${branchPrefix}-${env.IMAGE_TAG} → ${environment}"

                } finally {
                    // Always cleanup git credentials, even on failure
                    sh 'git config --global --unset credential.helper || true'
                }
            }
        }
    }
}

/**
 * Creates Maven settings.xml with Nexus credentials
 */
def createMavenSettings() {
    sh """
        cat > /tmp/maven-settings.xml <<'MAVEN_SETTINGS'
<?xml version="1.0" encoding="UTF-8"?>
<settings>
  <servers>
    <server>
      <id>nexus</id>
      <username>\${NEXUS_CREDENTIALS_USR}</username>
      <password>\${NEXUS_CREDENTIALS_PSW}</password>
    </server>
  </servers>
</settings>
MAVEN_SETTINGS
    """
}

// ============================================================================
// PIPELINE DEFINITION
// ============================================================================

pipeline {
    agent {
        kubernetes {
            yamlMergeStrategy merge()
            yaml """
apiVersion: v1
kind: Pod
spec:
  securityContext:
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
  containers:
  - name: jnlp
    envFrom:
    - configMapRef:
        name: pipeline-config
  - name: maven
    image: maven:3.9-eclipse-temurin-21
    command:
    - cat
    tty: true
    envFrom:
    - configMapRef:
        name: pipeline-config
    resources:
      requests:
        memory: "1Gi"
        cpu: "500m"
      limits:
        memory: "2Gi"
        cpu: "2000m"
  - name: cue
    image: alpine:3.19
    command:
    - cat
    tty: true
    envFrom:
    - configMapRef:
        name: pipeline-config
    env:
    - name: PATH
      value: /usr/local/bin:/usr/bin:/bin
    resources:
      requests:
        memory: "256Mi"
        cpu: "100m"
      limits:
        memory: "512Mi"
        cpu: "500m"
"""
        }
    }

    options {
        timeout(time: 1, unit: 'HOURS')
        buildDiscarder(logRotator(numToKeepStr: '10', daysToKeepStr: '30'))
        disableConcurrentBuilds()
    }

    parameters {
        booleanParam(
            name: 'SKIP_INTEGRATION_TESTS',
            defaultValue: false,
            description: 'Skip integration tests to speed up build'
        )
    }

    environment {
        // Application metadata
        APP_NAME = 'example-app'
        APP_GROUP = 'example'

        // Infrastructure URLs from pipeline-config ConfigMap (envFrom in pod spec)
        // These MUST be provided by the ConfigMap - no defaults, fail if missing

        // Credentials
        DOCKER_CREDENTIALS = credentials('docker-registry-credentials')
        NEXUS_CREDENTIALS = credentials('nexus-credentials')
        GITLAB_CREDENTIALS = credentials('gitlab-credentials')
        GITLAB_API_TOKEN = credentials('gitlab-api-token-secret')
    }

    stages {
        stage('Checkout & Setup') {
            steps {
                checkout scm
                container('maven') {
                    script {
                        echo "=== Checkout & Setup ==="

                        // Extract version from pom.xml
                        env.APP_VERSION = sh(
                            script: "mvn help:evaluate -Dexpression=project.version -q -DforceStdout",
                            returnStdout: true
                        ).trim()

                        // Generate image tag (version + git hash)
                        env.GIT_SHORT_HASH = sh(
                            script: "git rev-parse --short HEAD",
                            returnStdout: true
                        ).trim()

                        // Detect branch type and target environment (GitFlow)
                        def branchName = env.BRANCH_NAME ?: env.GIT_BRANCH?.replaceFirst('origin/', '')
                        if (branchName ==~ /feature\/.*/) {
                            env.BRANCH_TYPE = 'feature'
                            env.TARGET_ENV = 'dev'
                        } else if (branchName ==~ /release\/.*/) {
                            env.BRANCH_TYPE = 'release-candidate'
                            env.TARGET_ENV = 'stage'
                        } else if (branchName == 'main' || branchName == 'master') {
                            env.BRANCH_TYPE = 'release'
                            env.TARGET_ENV = 'prod'
                        } else {
                            // Other branches (hotfix, bugfix, etc.) default to dev
                            env.BRANCH_TYPE = 'feature'
                            env.TARGET_ENV = 'dev'
                        }
                        echo "Branch: ${branchName} -> Type: ${env.BRANCH_TYPE} -> Environment: ${env.TARGET_ENV}"

                        // Extract base version (strip any qualifiers for RC/release transformation)
                        def baseVersion = env.APP_VERSION.replaceAll('-SNAPSHOT.*', '').replaceAll('-RC\\..*', '')

                        // Version and tag logic based on branch type
                        switch(env.BRANCH_TYPE) {
                            case 'feature':
                                // SNAPSHOT versions - append commit hash to Docker tag for traceability
                                if (!env.APP_VERSION.endsWith('-SNAPSHOT')) {
                                    error("Feature branch must have SNAPSHOT version in pom.xml, got: ${env.APP_VERSION}")
                                }
                                env.IMAGE_TAG = "${env.APP_VERSION}-${env.GIT_SHORT_HASH}"
                                env.MAVEN_VERSION = env.APP_VERSION  // Keep as-is
                                env.NEXUS_REPO = 'maven-snapshots'
                                break

                            case 'release-candidate':
                                // RC versions - date-based for uniqueness
                                def today = new Date().format('yyyyMMdd')
                                env.MAVEN_VERSION = "${baseVersion}-RC.${today}"
                                env.IMAGE_TAG = env.MAVEN_VERSION
                                env.NEXUS_REPO = 'maven-releases'
                                break

                            case 'release':
                                // Release versions - clean, no qualifiers
                                if (env.APP_VERSION.contains('-SNAPSHOT') || env.APP_VERSION.contains('-RC')) {
                                    error("Main branch must have clean release version, got: ${env.APP_VERSION}")
                                }
                                env.MAVEN_VERSION = baseVersion
                                env.IMAGE_TAG = env.MAVEN_VERSION
                                env.NEXUS_REPO = 'maven-releases'
                                break
                        }

                        echo "Maven Version: ${env.MAVEN_VERSION}"
                        echo "Docker Tag: ${env.IMAGE_TAG}"
                        echo "Nexus Repo: ${env.NEXUS_REPO}"

                        // Validate IMAGE_TAG
                        if (!env.IMAGE_TAG || env.IMAGE_TAG.contains(' ')) {
                            error("Invalid IMAGE_TAG generated: '${env.IMAGE_TAG}'")
                        }

                        // Validate required ConfigMap values
                        def missing = []
                        if (!env.DOCKER_REGISTRY) missing.add('DOCKER_REGISTRY')
                        if (!env.GITLAB_INTERNAL_URL) missing.add('GITLAB_INTERNAL_URL')
                        if (!env.GITLAB_EXTERNAL_URL) missing.add('GITLAB_EXTERNAL_URL')
                        if (!env.GITLAB_GROUP) missing.add('GITLAB_GROUP')
                        if (!env.NEXUS_INTERNAL_URL) missing.add('NEXUS_INTERNAL_URL')
                        if (missing) {
                            error("Missing required ConfigMap values: ${missing.join(', ')} - check pipeline-config ConfigMap")
                        }

                        // Build image reference from ConfigMap values
                        env.IMAGE_NAME = "${env.DOCKER_REGISTRY}/${env.APP_GROUP}/${env.APP_NAME}"
                        env.FULL_IMAGE = "${env.IMAGE_NAME}:${env.IMAGE_TAG}"

                        // Registry for deployment manifests (external hostname for kubelet)
                        // This must match the ingress/external access to Nexus Docker registry
                        if (!env.DOCKER_REGISTRY_EXTERNAL) {
                            // Fall back to DOCKER_REGISTRY if external not specified separately
                            env.DOCKER_REGISTRY_EXTERNAL = env.DOCKER_REGISTRY
                        }
                        env.IMAGE_FOR_DEPLOY = "${env.DOCKER_REGISTRY_EXTERNAL}/${env.APP_GROUP}/${env.APP_NAME}:${env.IMAGE_TAG}"

                        echo "✓ Application: ${env.APP_NAME} v${env.APP_VERSION}"
                        echo "✓ Git commit: ${env.GIT_SHORT_HASH}"
                        echo "✓ Image tag: ${env.IMAGE_TAG}"
                        echo "✓ Push target: ${env.FULL_IMAGE}"
                        echo "✓ Deploy target: ${env.IMAGE_FOR_DEPLOY}"
                    }
                }
            }
        }

        stage('Unit Tests') {
            steps {
                container('maven') {
                    timeout(time: 15, unit: 'MINUTES') {
                        echo "=== Running Unit Tests ==="
                        sh 'mvn clean test'
                    }
                }
            }
            post {
                always {
                    junit '**/target/surefire-reports/*.xml'
                }
            }
        }

        stage('Integration Tests') {
            when {
                expression { return !params.SKIP_INTEGRATION_TESTS }
            }
            steps {
                container('maven') {
                    timeout(time: 20, unit: 'MINUTES') {
                        echo "=== Running Integration Tests ==="
                        sh 'mvn verify -DskipITs=false'
                    }
                }
            }
            post {
                always {
                    junit '**/target/failsafe-reports/*.xml'
                }
            }
        }

        stage('Build & Publish') {
            steps {
                container('maven') {
                    script {
                        timeout(time: 30, unit: 'MINUTES') {
                            echo "=== Building and Publishing Artifacts ==="

                            // Set version in pom.xml for RC/release builds
                            if (env.BRANCH_TYPE != 'feature') {
                                echo "Updating pom.xml version to ${env.MAVEN_VERSION}"
                                sh "mvn versions:set -DnewVersion=${env.MAVEN_VERSION} -DgenerateBackupPoms=false"
                            }

                            // Build and push Docker image with Jib
                            echo "Building Docker image..."
                            sh """
                                mvn clean package \
                                    -Dquarkus.container-image.build=true \
                                    -Dquarkus.container-image.push=true \
                                    -Dquarkus.container-image.registry=${DOCKER_REGISTRY} \
                                    -Dquarkus.container-image.group=${APP_GROUP} \
                                    -Dquarkus.container-image.name=${APP_NAME} \
                                    -Dquarkus.container-image.tag=${IMAGE_TAG} \
                                    -Dquarkus.container-image.insecure=true \
                                    -Dquarkus.container-image.username=${DOCKER_CREDENTIALS_USR} \
                                    -Dquarkus.container-image.password=${DOCKER_CREDENTIALS_PSW} \
                                    -DsendCredentialsOverHttp=true
                            """

                            // Publish Maven artifacts to Nexus
                            echo "Publishing Maven artifacts to Nexus..."
                            createMavenSettings()
                            echo "Deploying ${env.MAVEN_VERSION} to ${env.NEXUS_REPO} repository"

                            sh """
                                mvn deploy -DskipTests \
                                    -s /tmp/maven-settings.xml \
                                    -DaltDeploymentRepository=nexus::default::\${NEXUS_INTERNAL_URL}/repository/${env.NEXUS_REPO}/
                            """

                            echo "✓ Published Docker image: ${FULL_IMAGE}"
                            echo "✓ Published Maven artifact: ${APP_NAME}-${APP_VERSION}"
                        }
                    }
                }
            }
        }

        stage('Deploy') {
            steps {
                script {
                    def envUpper = env.TARGET_ENV.toUpperCase()
                    def mrTitle = "[${envUpper}] ${env.APP_NAME} ${env.IMAGE_TAG}"
                    def mrDesc = """## Automated Deployment from ${env.BRANCH_TYPE} Branch

**Application**: ${env.APP_NAME}
**Version**: ${env.MAVEN_VERSION}
**Docker Image**: ${env.FULL_IMAGE}
**Git Commit**: ${env.GIT_SHORT_HASH}
**Branch Type**: ${env.BRANCH_TYPE}
**Target Environment**: ${envUpper}

### Build Information

- Build URL: ${env.BUILD_URL}
- Nexus Repository: ${env.NEXUS_REPO}

### Testing

- ✅ Unit tests passed
- ✅ ${params.SKIP_INTEGRATION_TESTS ? 'Integration tests skipped' : 'Integration tests passed'}
- ✅ Build successful

### Deployment

Once this MR is merged, ArgoCD will automatically deploy to the **${env.TARGET_ENV}** namespace.

${env.TARGET_ENV == 'prod' ? '⚠️ **Production Deployment** - Please review carefully before merging.' : ''}

---
*Generated by Jenkins CI/CD Pipeline*"""

                    deployToEnvironment(
                        env.TARGET_ENV,
                        "deploy-${env.TARGET_ENV}",
                        mrTitle,
                        mrDesc
                    )
                }
            }
        }
    }

    post {
        success {
            echo """
=======================================================
✓ PIPELINE COMPLETED SUCCESSFULLY
=======================================================
Application: ${env.APP_NAME}
Version: ${env.APP_VERSION}
Git Commit: ${env.GIT_SHORT_HASH}
Image: ${env.FULL_IMAGE}
Build URL: ${env.BUILD_URL}
=======================================================
"""
        }
        failure {
            echo """
=======================================================
✗ PIPELINE FAILED
=======================================================
Application: ${env.APP_NAME}
Build URL: ${env.BUILD_URL}
Check logs above for error details
=======================================================
"""
        }
        always {
            container('maven') {
                script {
                    // Cleanup temporary files and credentials
                    sh '''
                        echo "Performing cleanup..."
                        git config --global --unset credential.helper || true
                        rm -rf k8s-deployments || true
                        rm -f /tmp/maven-settings.xml || true
                        echo "✓ Cleanup completed"
                    '''
                }
            }
        }
    }
}
