// Production-Ready Jenkinsfile for example-app CI/CD pipeline
// Refactored for maintainability, reliability, and production best practices

/**
 * Configures git credentials and identity, executes body, then cleans up.
 * Uses local git config when repoDir is provided (preferred), falls back to --global.
 * @param repoDir Optional directory for local git config scope. If null/empty, uses --global.
 * @param body Closure to execute with credentials configured
 */
def withGitCredentials(String repoDir = null, Closure body) {
    def gitCmd = 'git config --global'
    if (repoDir?.trim()) {
        if (!fileExists(repoDir)) {
            error "withGitCredentials: repoDir '${repoDir}' does not exist"
        }
        gitCmd = "git -C ${repoDir} config"
    }
    try {
        sh """
            ${gitCmd} user.name 'Jenkins CI'
            ${gitCmd} user.email 'jenkins@local'
            ${gitCmd} credential.helper '!f() { printf "username=%s\\npassword=%s\\n" "\${GIT_USERNAME}" "\${GIT_PASSWORD}"; }; f'
        """
        body()
    } finally {
        sh """
            ${gitCmd} --unset credential.helper || true
            ${gitCmd} --unset user.name || true
            ${gitCmd} --unset user.email || true
        """
    }
}

/**
 * Validates that all listed environment variables are set.
 * Fails the build with a clear message listing all missing variables.
 * @param vars List of environment variable names to check
 */
def validateRequiredEnvVars(List<String> vars) {
    def missing = vars.findAll { !env."${it}" }
    if (missing) {
        error "Missing required ConfigMap variables: ${missing.join(', ')}. Check pipeline-config ConfigMap in Jenkins namespace."
    }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Deploys to an environment by updating image and creating GitLab merge request
 * Used for dev environment (initial deployment from build)
 * @param environment Target environment (dev)
 * @param branchPrefix Prefix for feature branch name
 * @param mrTitle Title for the merge request
 * @param mrDescription Detailed description for the merge request
 */
def deployToEnvironment(String environment, String branchPrefix, String mrTitle, String mrDescription) {
    container('maven') {
        script {
            echo "[${environment.toUpperCase()}] Creating environment update and MR..."

            withCredentials([usernamePassword(credentialsId: 'gitlab-credentials',
                                              usernameVariable: 'GIT_USERNAME',
                                              passwordVariable: 'GIT_PASSWORD')]) {
                withGitCredentials {
                    // Clone or update deployment repository
                    sh """
                        rm -rf k8s-deployments
                        git clone ${DEPLOYMENT_REPO} k8s-deployments
                        cd k8s-deployments

                        # Fetch and checkout target environment branch
                        git fetch origin ${environment}
                        git checkout ${environment}
                        git pull origin ${environment}

                        # Create feature branch for this update
                        FEATURE_BRANCH="${branchPrefix}-\${IMAGE_TAG}"
                        git checkout -b "\${FEATURE_BRANCH}"
                    """

                    // Update environment configuration (L5 + L6 only, no manifest generation)
                    sh """
                        cd k8s-deployments

                        # L5: Sync app.cue from source repo (if exists)
                        if [ -f "\${WORKSPACE}/deployment/app.cue" ]; then
                            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                            echo "Syncing deployment configuration (L5)..."
                            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                            mkdir -p services/apps
                            cp \${WORKSPACE}/deployment/app.cue services/apps/\${APP_NAME}.cue
                            echo "✓ Synced services/apps/\${APP_NAME}.cue"
                        fi

                        # L6: Update image tag in env.cue
                        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                        echo "Updating image tag (L6)..."
                        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                        ./scripts/update-app-image.sh ${environment} ${APP_NAME} "${FULL_IMAGE}"
                        echo "✓ Updated ${APP_NAME} image in env.cue"

                        # Stage CUE changes only - k8s-deployments CI will generate manifests
                        git add services/apps/ env.cue 2>/dev/null || git add env.cue

                        # Commit with metadata
                        git commit -m "${mrTitle}

L5/L6 update from application CI/CD pipeline.

Changes:
- Synced services/apps/\${APP_NAME}.cue (if changed)
- Updated ${environment} environment image to \${IMAGE_TAG}

Note: Manifests will be generated by k8s-deployments CI.

Build: \${BUILD_URL}
Git commit: \${GIT_SHORT_HASH}
Image: ${FULL_IMAGE}" || echo "No changes to commit"
                    """

                    // Push feature branch and create merge request
                    sh """
                        cd k8s-deployments
                        FEATURE_BRANCH="${branchPrefix}-\${IMAGE_TAG}"

                        # Delete remote branch if it exists, then push fresh
                        git push origin --delete "\${FEATURE_BRANCH}" 2>/dev/null || echo "Branch does not exist remotely"
                        git push -u origin "\${FEATURE_BRANCH}"

                        # Create MR using GitLab API
                        export GITLAB_TOKEN="${GITLAB_API_TOKEN}"
                        export GITLAB_URL_INTERNAL="${GITLAB_URL}"
                        export GITLAB_GROUP="${GITLAB_GROUP}"

                        ./scripts/create-gitlab-mr.sh \
                            "\${FEATURE_BRANCH}" \
                            ${environment} \
                            "${mrTitle}" \
                            "${mrDescription}"
                    """

                    echo "[${environment.toUpperCase()}] ✓ MR created successfully: ${branchPrefix}-${env.IMAGE_TAG} → ${environment}"
                }
            }
        }
    }
}

/**
 * Creates Maven settings.xml with Nexus credentials
 */
def createMavenSettings() {
    sh """
        cat > /tmp/maven-settings.xml <<'MAVEN_SETTINGS'
<?xml version="1.0" encoding="UTF-8"?>
<settings>
  <servers>
    <server>
      <id>nexus</id>
      <username>\${NEXUS_CREDENTIALS_USR}</username>
      <password>\${NEXUS_CREDENTIALS_PSW}</password>
    </server>
  </servers>
</settings>
MAVEN_SETTINGS
    """
}

// ============================================================================
// PIPELINE DEFINITION
// ============================================================================

// Get agent image from system environment (set via ConfigMap envFrom)
def agentImage = System.getenv('JENKINS_AGENT_IMAGE')
if (!agentImage) { error "JENKINS_AGENT_IMAGE not set - check pipeline-config ConfigMap" }

pipeline {
    agent {
        kubernetes {
            yaml """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: maven
    image: ${agentImage}
    command:
    - cat
    tty: true
    resources:
      requests:
        memory: "1Gi"
        cpu: "500m"
      limits:
        memory: "2Gi"
        cpu: "2000m"
    volumeMounts:
    - name: docker-sock
      mountPath: /var/run/docker.sock
  volumes:
  - name: docker-sock
    hostPath:
      path: /var/run/docker.sock
"""
        }
    }

    options {
        timeout(time: 1, unit: 'HOURS')
        buildDiscarder(logRotator(numToKeepStr: '10', daysToKeepStr: '30'))
        disableConcurrentBuilds()
    }

    parameters {
        booleanParam(
            name: 'SKIP_INTEGRATION_TESTS',
            defaultValue: false,
            description: 'Skip integration tests to speed up build'
        )
    }

    environment {
        // Application metadata
        APP_NAME = 'example-app'
        APP_GROUP = 'p2c'

        // Container registry - use external URL (nodes trust it, no CA changes needed)
        CONTAINER_REGISTRY = "${env.DOCKER_REGISTRY_EXTERNAL ?: ''}"

        // Maven repository (internal Nexus for artifacts, torn down with demo)
        MAVEN_REPO_URL = "${env.NEXUS_URL_INTERNAL ?: ''}"

        // Git repositories (from pipeline-config ConfigMap)
        GITLAB_URL = "${env.GITLAB_URL_INTERNAL ?: ''}"
        GITLAB_GROUP = "${env.GITLAB_GROUP ?: ''}"
        DEPLOYMENT_REPO = "${env.DEPLOYMENTS_REPO_URL ?: ''}"

        // Credentials
        NEXUS_CREDENTIALS = credentials('nexus-credentials')
        DOCKER_CREDENTIALS = credentials('docker-registry-credentials')
        GITLAB_CREDENTIALS = credentials('gitlab-credentials')
        GITLAB_API_TOKEN = credentials('gitlab-api-token-secret')

        // Computed image reference
        IMAGE_NAME = "${CONTAINER_REGISTRY}/${APP_GROUP}/${APP_NAME}"
    }

    stages {
        stage('Checkout & Setup') {
            steps {
                checkout scm
                container('maven') {
                    script {
                        echo "=== Checkout & Setup ==="

                        // Validate required environment variables from ConfigMap
                        validateRequiredEnvVars(['JENKINS_AGENT_IMAGE', 'GITLAB_URL_INTERNAL', 'DEPLOYMENTS_REPO_URL', 'DOCKER_REGISTRY_EXTERNAL'])

                        // Extract version from pom.xml
                        env.APP_VERSION = sh(
                            script: "mvn help:evaluate -Dexpression=project.version -q -DforceStdout",
                            returnStdout: true
                        ).trim()

                        // Generate image tag (version + git hash)
                        env.GIT_SHORT_HASH = sh(
                            script: "git rev-parse --short HEAD",
                            returnStdout: true
                        ).trim()

                        // Capture full commit SHA for GitLab commit status reporting
                        env.GIT_COMMIT_SHA = sh(
                            script: "git rev-parse HEAD",
                            returnStdout: true
                        ).trim()

                        env.IMAGE_TAG = "${env.APP_VERSION}-${env.GIT_SHORT_HASH}"

                        // Validate IMAGE_TAG
                        if (!env.IMAGE_TAG || env.IMAGE_TAG.contains(' ')) {
                            error("Invalid IMAGE_TAG generated: '${env.IMAGE_TAG}'")
                        }

                        env.FULL_IMAGE = "${env.IMAGE_NAME}:${env.IMAGE_TAG}"

                        echo "✓ Application: ${env.APP_NAME} v${env.APP_VERSION}"
                        echo "✓ Git commit: ${env.GIT_SHORT_HASH}"
                        echo "✓ Image tag: ${env.IMAGE_TAG}"
                        echo "✓ Deploy target: ${env.FULL_IMAGE}"

                        // Report "pending" status to GitLab so MR shows pipeline is running
                        withCredentials([string(credentialsId: 'gitlab-api-token-secret', variable: 'GITLAB_TOKEN')]) {
                            sh """
                                echo "Reporting pending status to GitLab for commit: ${env.GIT_COMMIT_SHA}"
                                curl -s -X POST \
                                    -H "PRIVATE-TOKEN: \${GITLAB_TOKEN}" \
                                    -H "Content-Type: application/json" \
                                    -d '{"state": "pending", "description": "Pipeline running", "context": "jenkins/example-app"}' \
                                    "${env.GITLAB_URL}/api/v4/projects/${env.GITLAB_GROUP ?: 'p2c'}%2Fexample-app/statuses/${env.GIT_COMMIT_SHA}" \
                                    || echo "Could not update commit status (non-fatal)"
                            """
                        }
                    }
                }
            }
        }

        stage('Unit Tests') {
            steps {
                container('maven') {
                    timeout(time: 15, unit: 'MINUTES') {
                        echo "=== Running Unit Tests ==="
                        sh 'mvn clean test'
                    }
                }
            }
            post {
                always {
                    junit '**/target/surefire-reports/*.xml'
                }
            }
        }

        stage('Integration Tests') {
            when {
                expression { return !params.SKIP_INTEGRATION_TESTS }
            }
            steps {
                container('maven') {
                    timeout(time: 20, unit: 'MINUTES') {
                        echo "=== Running Integration Tests ==="
                        sh 'mvn verify -DskipITs=false'
                    }
                }
            }
            post {
                always {
                    junit '**/target/failsafe-reports/*.xml'
                }
            }
        }

        stage('Build & Publish') {
            steps {
                container('maven') {
                    script {
                        timeout(time: 30, unit: 'MINUTES') {
                            echo "=== Building and Publishing Artifacts ==="

                            // Build and push Docker image with Jib
                            echo "Building and pushing container image..."
                            sh """
                                mvn clean package \
                                    -Dquarkus.container-image.build=true \
                                    -Dquarkus.container-image.push=true \
                                    -Dquarkus.container-image.registry=${CONTAINER_REGISTRY} \
                                    -Dquarkus.container-image.group=${APP_GROUP} \
                                    -Dquarkus.container-image.name=${APP_NAME} \
                                    -Dquarkus.container-image.tag=${IMAGE_TAG} \
                                    -Dquarkus.container-image.insecure=true \
                                    -Dquarkus.container-image.username=${DOCKER_CREDENTIALS_USR} \
                                    -Dquarkus.container-image.password=${DOCKER_CREDENTIALS_PSW} \
                                    -DsendCredentialsOverHttp=true
                            """

                            // Publish Maven artifacts to Nexus
                            echo "Publishing Maven artifacts to Nexus..."
                            createMavenSettings()

                            // Determine repository based on version type
                            def repoPath
                            if (env.APP_VERSION.endsWith('-SNAPSHOT')) {
                                repoPath = 'maven-snapshots'
                                echo "Deploying SNAPSHOT version to maven-snapshots repository"
                            } else {
                                repoPath = 'maven-releases'
                                echo "Deploying release version to maven-releases repository"
                            }

                            sh """
                                mvn deploy -DskipTests \
                                    -s /tmp/maven-settings.xml \
                                    -DaltDeploymentRepository=nexus::default::${MAVEN_REPO_URL}/repository/${repoPath}/
                            """

                            echo "✓ Published container image: ${FULL_IMAGE}"
                            echo "✓ Published Maven artifact: ${APP_NAME}-${APP_VERSION}"
                        }
                    }
                }
            }
        }

        stage('Update Dev Environment') {
            when {
                // Only update dev from main branch - feature branches are for MR CI only
                branch 'main'
            }
            steps {
                script {
                    deployToEnvironment(
                        'dev',
                        'update-dev',
                        "Deploy ${env.APP_NAME} to dev: ${env.IMAGE_TAG}",
                        """## Automatic Deployment to Dev

**Application**: ${env.APP_NAME}
**Image Tag**: ${env.IMAGE_TAG}
**Build**: ${env.BUILD_URL}
**Git Commit**: ${env.GIT_SHORT_HASH}

### Changes

This merge request updates the dev environment with the latest build.

**Image**: ${env.FULL_IMAGE}

### Review Checklist

- [ ] Image tag is correct
- [ ] CUE configuration updated (L5/L6)
- [ ] Ready to merge (k8s-deployments CI will generate manifests)

Once merged, k8s-deployments CI will generate manifests and ArgoCD will deploy to dev.

---
*Generated by Jenkins CI/CD Pipeline*"""
                    )
                }
            }
        }

    }

    post {
        success {
            script {
                echo """
=======================================================
✓ PIPELINE COMPLETED SUCCESSFULLY
=======================================================
Application: ${env.APP_NAME}
Version: ${env.APP_VERSION}
Git Commit: ${env.GIT_SHORT_HASH}
Image: ${env.FULL_IMAGE}
Build URL: ${env.BUILD_URL}
=======================================================
"""
                // Report success status to GitLab
                container('maven') {
                    withCredentials([string(credentialsId: 'gitlab-api-token-secret', variable: 'GITLAB_TOKEN')]) {
                        sh """
                            echo "Reporting success status to GitLab for commit: ${env.GIT_COMMIT_SHA}"
                            curl -s -X POST \
                                -H "PRIVATE-TOKEN: \${GITLAB_TOKEN}" \
                                -H "Content-Type: application/json" \
                                -d '{"state": "success", "description": "Pipeline passed", "context": "jenkins/example-app"}' \
                                "${env.GITLAB_URL}/api/v4/projects/${env.GITLAB_GROUP ?: 'p2c'}%2Fexample-app/statuses/${env.GIT_COMMIT_SHA}" \
                                || echo "Could not update commit status"
                        """
                    }
                }
            }
        }
        failure {
            script {
                echo """
=======================================================
✗ PIPELINE FAILED
=======================================================
Application: ${env.APP_NAME}
Build URL: ${env.BUILD_URL}
Check logs above for error details
=======================================================
"""
                // Report failure status to GitLab
                container('maven') {
                    withCredentials([string(credentialsId: 'gitlab-api-token-secret', variable: 'GITLAB_TOKEN')]) {
                        sh """
                            echo "Reporting failure status to GitLab for commit: ${env.GIT_COMMIT_SHA}"
                            curl -s -X POST \
                                -H "PRIVATE-TOKEN: \${GITLAB_TOKEN}" \
                                -H "Content-Type: application/json" \
                                -d '{"state": "failed", "description": "Pipeline failed", "context": "jenkins/example-app"}' \
                                "${env.GITLAB_URL}/api/v4/projects/${env.GITLAB_GROUP ?: 'p2c'}%2Fexample-app/statuses/${env.GIT_COMMIT_SHA}" \
                                || echo "Could not update commit status"
                        """
                    }
                }
            }
        }
        always {
            container('maven') {
                script {
                    // Cleanup temporary files and credentials
                    sh '''
                        echo "Performing cleanup..."
                        git config --global --unset credential.helper || true
                        rm -rf k8s-deployments || true
                        rm -f /tmp/maven-settings.xml || true
                        echo "✓ Cleanup completed"
                    '''
                }
            }
        }
    }
}
