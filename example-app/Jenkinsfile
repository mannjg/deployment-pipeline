import groovy.transform.Field

// Production-Ready Jenkinsfile for example-app CI/CD pipeline
// Refactored for maintainability, reliability, and production best practices

@Field def helpers = null

def loadHelpers() {
    if (helpers == null) {
        helpers = load 'Jenkinsfile.helpers.groovy'
    }
    return helpers
}

// Agent image from system environment (set via ConfigMap envFrom).
// System.getenv() is required here because this runs at Groovy parse time,
// before the pipeline environment block is evaluated.
def getAgentImageOrFail(String envVarName = 'JENKINS_AGENT_IMAGE') {
    def agentImage = System.getenv(envVarName)
    if (!agentImage) {
        error "${envVarName} not set - check pipeline-config ConfigMap"
    }
    return agentImage
}

def podTemplateYaml(String agentImage) {
    return """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: pipeline
    image: ${agentImage}
    command:
    - cat
    tty: true
    env:
    - name: DOCKER_HOST
      value: tcp://localhost:2375
    resources:
      requests:
        memory: "1Gi"
        cpu: "500m"
      limits:
        memory: "2Gi"
        cpu: "2000m"
  - name: dind
    image: docker:dind
    securityContext:
      privileged: true
    env:
    - name: DOCKER_TLS_CERTDIR
      value: ""
    args:
    - --insecure-registry=${env.CONTAINER_REGISTRY_EXTERNAL?.replaceAll('^https?://', '')}
    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "2Gi"
        cpu: "1000m"
"""
}

def gitlabStatusContext = 'jenkins/example-app'

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Deploys to an environment by updating image and creating GitLab merge request
 * Used for dev environment (initial deployment from build)
 * @param environment Target environment (dev)
 * @param branchPrefix Prefix for feature branch name
 * @param mrTitle Title for the merge request
 * @param mrDescription Detailed description for the merge request
 */
def deployToEnvironment(String environment, String branchPrefix, String mrTitle, String mrDescription) {
    container('pipeline') {
        script {
            def h = loadHelpers()
            echo "[${environment.toUpperCase()}] Creating environment update and MR..."

            // Write MR description to temp file (multi-line content can break withEnv)
            def mrDescriptionFile = h.tempFilePath('mr-description', '.txt')
            writeFile file: mrDescriptionFile, text: mrDescription

            // Scope Groovy function params as env vars for sh ''' blocks (not global env.*)
            withEnv([
                "DEPLOY_ENV=${environment}",
                "DEPLOY_BRANCH_PREFIX=${branchPrefix}",
                "DEPLOY_MR_TITLE=${mrTitle}"
            ]) {
                withCredentials([
                    usernamePassword(credentialsId: 'gitlab-credentials',
                                      usernameVariable: 'GIT_USERNAME',
                                      passwordVariable: 'GIT_PASSWORD'),
                    string(credentialsId: 'gitlab-api-token-secret', variable: 'GITLAB_TOKEN')
                ]) {
                    // Phase 1: Clone requires global credential helper (repo doesn't exist yet)
                    h.withGitCredentials {
                        sh '''
                            rm -rf k8s-deployments
                            git clone "${DEPLOYMENT_REPO}" k8s-deployments
                        '''
                    }
                    // Phase 2: All subsequent operations use repo-scoped config
                    h.withGitCredentials('k8s-deployments') {
                        sh "./scripts/deploy-to-environment.sh k8s-deployments ${mrDescriptionFile}"

                        if (fileExists(h.tempFilePath('no-changes'))) {
                            echo "[${environment.toUpperCase()}] No changes detected - MR creation skipped (image tag already current)"
                        } else {
                            echo "[${environment.toUpperCase()}] ✓ MR created successfully: ${branchPrefix}-${env.IMAGE_TAG} → ${environment}"
                        }
                    }
                }
            }
        }
    }
}

// ============================================================================
// PIPELINE DEFINITION
// ============================================================================

// Get agent image from system environment (set via ConfigMap envFrom)
def agentImage = getAgentImageOrFail()

pipeline {
    agent {
        kubernetes {
            yaml podTemplateYaml(agentImage)
        }
    }

    options {
        timestamps()
        ansiColor('xterm')
        timeout(time: 1, unit: 'HOURS')
        buildDiscarder(logRotator(numToKeepStr: '10', daysToKeepStr: '30'))
        disableConcurrentBuilds()
    }

    parameters {
        booleanParam(
            name: 'SKIP_INTEGRATION_TESTS',
            defaultValue: false,
            description: 'Skip integration tests to speed up build'
        )
    }

    environment {
        // Application metadata
        APP_NAME = 'example-app'
        APP_GROUP = "${env.CONTAINER_REGISTRY_PATH_PREFIX ?: ''}"

        // Container registry - use external URL (nodes trust it, no CA changes needed)
        CONTAINER_REGISTRY = "${env.CONTAINER_REGISTRY_EXTERNAL ?: ''}"

        // Maven repository (internal Nexus for artifacts, torn down with demo)
        MAVEN_REPO_URL = "${env.MAVEN_REPO_URL_INTERNAL ?: ''}"

        // Git repositories (from pipeline-config ConfigMap)
        GITLAB_URL = "${env.GITLAB_URL_INTERNAL ?: ''}"
        GITLAB_GROUP = "${env.GITLAB_GROUP ?: ''}"
        DEPLOYMENT_REPO = "${env.DEPLOYMENTS_REPO_URL ?: ''}"

        // Computed image reference
        IMAGE_NAME = "${CONTAINER_REGISTRY}/${APP_GROUP}/${APP_NAME}"
    }

    stages {
        stage('Checkout & Setup') {
            steps {
                checkout scm
                container('pipeline') {
                    script {
                        echo "=== Checkout & Setup ==="

                        // Validate required environment variables from ConfigMap
                        loadHelpers().validateRequiredEnvVars(['JENKINS_AGENT_IMAGE', 'GITLAB_URL_INTERNAL', 'GITLAB_GROUP', 'DEPLOYMENTS_REPO_URL', 'CONTAINER_REGISTRY_EXTERNAL', 'CONTAINER_REGISTRY_PATH_PREFIX'])

                        // Extract version from pom.xml
                        env.APP_VERSION = sh(
                            script: "mvn help:evaluate -Dexpression=project.version -q -DforceStdout",
                            returnStdout: true
                        ).trim()

                        // Generate image tag (version + git hash)
                        env.GIT_SHORT_HASH = sh(
                            script: "git rev-parse --short HEAD",
                            returnStdout: true
                        ).trim()

                        // Capture full commit SHA for GitLab commit status reporting
                        env.GIT_COMMIT_SHA = sh(
                            script: "git rev-parse HEAD",
                            returnStdout: true
                        ).trim()

                        env.IMAGE_TAG = "${env.APP_VERSION}-${env.GIT_SHORT_HASH}"

                        // Validate IMAGE_TAG
                        if (!env.IMAGE_TAG || env.IMAGE_TAG.contains(' ')) {
                            error("Invalid IMAGE_TAG generated: '${env.IMAGE_TAG}'")
                        }

                        env.FULL_IMAGE = "${env.IMAGE_NAME}:${env.IMAGE_TAG}"

                        echo "✓ Application: ${env.APP_NAME} v${env.APP_VERSION}"
                        echo "✓ Git commit: ${env.GIT_SHORT_HASH}"
                        echo "✓ Image tag: ${env.IMAGE_TAG}"
                        echo "✓ Deploy target: ${env.FULL_IMAGE}"

                        // Report "pending" status to GitLab so MR shows pipeline is running
                        loadHelpers().reportGitLabStatus('pending', gitlabStatusContext, env.GIT_COMMIT_SHA, "${env.GITLAB_GROUP}/example-app")
                    }
                }
            }
        }

        stage('Unit Tests') {
            steps {
                container('pipeline') {
                    timeout(time: 15, unit: 'MINUTES') {
                        echo "=== Running Unit Tests ==="
                        sh 'mvn clean test'
                    }
                }
            }
            post {
                always {
                    junit '**/target/surefire-reports/*.xml'
                }
            }
        }

        stage('Integration Tests') {
            when {
                expression { return !params.SKIP_INTEGRATION_TESTS }
            }
            steps {
                container('pipeline') {
                    timeout(time: 20, unit: 'MINUTES') {
                        echo "=== Running Integration Tests ==="
                        sh 'mvn verify -DskipITs=false'
                    }
                }
            }
            post {
                always {
                    junit '**/target/failsafe-reports/*.xml'
                }
            }
        }

        stage('Build & Publish') {
            steps {
                container('pipeline') {
                    script {
                        timeout(time: 30, unit: 'MINUTES') {
                            echo "=== Building and Publishing Artifacts ==="

                            withCredentials([
                                usernamePassword(credentialsId: 'maven-repo-credentials',
                                                usernameVariable: 'MAVEN_REPO_CREDENTIALS_USR',
                                                passwordVariable: 'MAVEN_REPO_CREDENTIALS_PSW'),
                                usernamePassword(credentialsId: 'container-registry-credentials',
                                                usernameVariable: 'CONTAINER_REGISTRY_CREDENTIALS_USR',
                                                passwordVariable: 'CONTAINER_REGISTRY_CREDENTIALS_PSW')
                            ]) {
                                // Deploy Maven artifact first — fails fast on duplicate
                                // release before pushing a Docker image (JENKINS-26)
                                echo "Publishing Maven artifacts to Nexus..."

                            // Determine repository based on version type
                            def repoPath
                            if (env.APP_VERSION.endsWith('-SNAPSHOT')) {
                                repoPath = 'maven-snapshots'
                                echo "Deploying SNAPSHOT version to maven-snapshots repository"
                            } else {
                                repoPath = 'maven-releases'
                                echo "Deploying release version to maven-releases repository"
                            }

                            // Generate scoped Maven settings and deploy in a single script.
                            // mktemp + trap ensures cleanup on success, failure, or abort.
                            echo "Building and pushing container image..."
                            sh "./scripts/build-publish.sh ${repoPath}"
                            echo "✓ Published Maven artifact: ${APP_NAME}-${APP_VERSION}"

                                // Build and push Docker image with Jib (reuses build output)
                                echo "✓ Published container image: ${FULL_IMAGE}"
                            }
                        }
                    }
                }
            }
        }

        stage('Update Dev Environment') {
            when {
                // Only update dev from main branch - feature branches are for MR CI only
                branch 'main'
            }
            steps {
                script {
                    deployToEnvironment(
                        'dev',
                        'update-dev',
                        "Deploy ${env.APP_NAME} to dev: ${env.IMAGE_TAG}",
                        """## Automatic Deployment to Dev

**Application**: ${env.APP_NAME}
**Image Tag**: ${env.IMAGE_TAG}
**Build**: ${env.BUILD_URL}
**Git Commit**: ${env.GIT_SHORT_HASH}

### Changes

This merge request updates the dev environment with the latest build.

**Image**: ${env.FULL_IMAGE}

### Review Checklist

- [ ] Image tag is correct
- [ ] CUE configuration updated (L5/L6)
- [ ] Ready to merge (k8s-deployments CI will generate manifests)

Once merged, k8s-deployments CI will generate manifests and ArgoCD will deploy to dev.

---
*Generated by Jenkins CI/CD Pipeline*"""
                    )
                }
            }
        }

    }

    post {
        success {
            script {
                echo """
=======================================================
✓ PIPELINE COMPLETED SUCCESSFULLY
=======================================================
Application: ${env.APP_NAME}
Version: ${env.APP_VERSION}
Git Commit: ${env.GIT_SHORT_HASH}
Image: ${env.FULL_IMAGE}
Build URL: ${env.BUILD_URL}
=======================================================
"""
                // Report success status to GitLab
                container('pipeline') {
                    loadHelpers().reportGitLabStatus('success', gitlabStatusContext, env.GIT_COMMIT_SHA, "${env.GITLAB_GROUP}/example-app")
                }
            }
        }
        failure {
            script {
                echo """
=======================================================
✗ PIPELINE FAILED
=======================================================
Application: ${env.APP_NAME}
Build URL: ${env.BUILD_URL}
Check logs above for error details
=======================================================
"""
                // Report failure status to GitLab
                container('pipeline') {
                    loadHelpers().reportGitLabStatus('failed', gitlabStatusContext, env.GIT_COMMIT_SHA, "${env.GITLAB_GROUP}/example-app")
                }
            }
        }
        always {
            container('pipeline') {
                script {
                    // Cleanup temporary files and credentials
                    sh '''
                        echo "Performing cleanup..."
                        rm -rf k8s-deployments || true
                        echo "Cleanup completed"
                    '''
                    loadHelpers().cleanupWorkspaceFiles(['.no-changes-*', '.mr-description-*'])
                }
            }
        }
    }
}
