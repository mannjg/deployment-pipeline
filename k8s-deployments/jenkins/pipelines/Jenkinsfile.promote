import groovy.transform.Field

@Field def helpers = null

def loadHelpers() {
    if (helpers == null) {
        helpers = load 'Jenkinsfile.helpers.groovy'
    }
    return helpers
}

def promoteBranchPrefix() {
    return env.PIPELINE_PROMOTE_PREFIX
}

// Agent image from system environment (set via ConfigMap envFrom).
// System.getenv() is required here because this runs at Groovy parse time,
// before the pipeline environment block is evaluated.
def getAgentImageOrFail(String envVarName = 'JENKINS_AGENT_IMAGE') {
    def agentImage = System.getenv(envVarName)
    if (!agentImage) {
        error "${envVarName} environment variable is required but not set. Configure it in the pipeline-config ConfigMap."
    }
    return agentImage
}

def podTemplateYaml(String agentImage) {
    return """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: pipeline
    image: ${agentImage}
    command:
    - cat
    tty: true
    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "1Gi"
        cpu: "1000m"
"""
}

/**
 * Jenkins Pipeline: Promote Environment
 *
 * Purpose: Promote an application from one environment to the next by:
 * 1. Auto-detecting the image from source environment deployment (or using provided IMAGE_TAG)
 * 2. Updating the image in target environment's env.cue
 * 3. Regenerating Kubernetes manifests
 * 4. Creating a GitLab MR targeting the target environment branch
 *
 * Valid promotion paths:
 *   dev -> stage
 *   stage -> prod
 *
 * This pipeline replaces the inline promotion logic that was previously in the CI pipeline,
 * ensuring that fixes made during dev MR review propagate correctly to stage/prod.
 */

// Agent image from system environment (set via ConfigMap envFrom).
// System.getenv() is required here because this runs at Groovy parse time,
// before the pipeline environment block is evaluated.
def agentImage = getAgentImageOrFail()

pipeline {
    agent {
        kubernetes {
            yaml podTemplateYaml(agentImage)
        }
    }

    options {
        timestamps()
        ansiColor('xterm')
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '20', daysToKeepStr: '30'))
        disableConcurrentBuilds()
    }

    parameters {
        string(
            name: 'APP_NAME',
            defaultValue: 'example-app',
            description: 'Application name to promote (e.g., example-app)'
        )
        choice(
            name: 'SOURCE_ENV',
            choices: ['dev', 'stage'],
            description: 'Source environment to promote FROM'
        )
        choice(
            name: 'TARGET_ENV',
            choices: ['stage', 'prod'],
            description: 'Target environment to promote TO'
        )
        string(
            name: 'IMAGE_TAG',
            defaultValue: '',
            description: 'Optional: Image tag to promote (e.g., 1.0.0-abc123). If empty, auto-detects from source environment deployment.'
        )
    }

    environment {
        // Git repositories (from pipeline-config ConfigMap)
        GITLAB_URL = "${env.GITLAB_URL_INTERNAL ?: ''}"
        GITLAB_GROUP = "${env.GITLAB_GROUP ?: ''}"
        DEPLOYMENT_REPO = "${env.DEPLOYMENTS_REPO_URL ?: ''}"

        // External registry for deployment manifests (what kubelet uses to pull)
        DEPLOY_REGISTRY = "${env.CONTAINER_REGISTRY_EXTERNAL ?: ''}"

        // Container registry path prefix (e.g., 'p2c' for registry/p2c/example-app)
        APP_GROUP = "${env.CONTAINER_REGISTRY_PATH_PREFIX ?: ''}"

    }

    stages {
        stage('Validate Parameters') {
            steps {
                container('pipeline') {
                    script {
                        echo "=== Validate Promotion Parameters ==="

                        // Validate required environment variables
                        loadHelpers().validateRequiredEnvVars(['JENKINS_AGENT_IMAGE', 'GITLAB_URL_INTERNAL', 'GITLAB_GROUP', 'DEPLOYMENTS_REPO_URL', 'CONTAINER_REGISTRY_EXTERNAL', 'CONTAINER_REGISTRY_PATH_PREFIX'])
                        loadHelpers().pipelineConfigWriteEnv('PIPELINE_PROMOTE_PREFIX', '.branches.promote_prefix')

                        // Validate promotion path
                        def validPromotions = [
                            'dev': 'stage',
                            'stage': 'prod'
                        ]

                        def expectedTarget = validPromotions[params.SOURCE_ENV]
                        if (expectedTarget != params.TARGET_ENV) {
                            error """Invalid promotion path: ${params.SOURCE_ENV} -> ${params.TARGET_ENV}

Valid promotion paths:
  - dev -> stage
  - stage -> prod

You selected: ${params.SOURCE_ENV} -> ${params.TARGET_ENV}"""
                        }

                        echo "Promotion path validated: ${params.SOURCE_ENV} -> ${params.TARGET_ENV}"
                        echo "Application: ${params.APP_NAME}"
                        echo "Image tag: ${params.IMAGE_TAG ?: '(will auto-detect)'}"
                    }
                }
            }
        }

        stage('Detect Image') {
            steps {
                container('pipeline') {
                    script {
                        echo "=== Detect Image to Promote ==="

                        if (params.IMAGE_TAG?.trim()) {
                            // Use provided image tag
                            env.PROMOTE_IMAGE_TAG = params.IMAGE_TAG.trim()
                            echo "Using provided image tag: ${env.PROMOTE_IMAGE_TAG}"
                        } else {
                            // Auto-detect from source environment deployment
                            echo "Auto-detecting image from ${params.SOURCE_ENV} environment..."

                            // Map environment to namespace (they're the same in this project)
                            def namespace = params.SOURCE_ENV

                            // Get the current image from the deployment
                            def currentImage = sh(
                                script: """
                                    kubectl get deployment ${params.APP_NAME} -n ${namespace} \
                                        -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null || echo ""
                                """,
                                returnStdout: true
                            ).trim()

                            if (!currentImage) {
                                error """Could not detect image for ${params.APP_NAME} in ${namespace} namespace.

Ensure the application is deployed to ${params.SOURCE_ENV} before promoting.
Check: kubectl get deployment ${params.APP_NAME} -n ${namespace}"""
                            }

                            // Extract the tag from the full image reference
                            // Format: registry/group/name:tag
                            def imageTag = currentImage.tokenize(':').last()
                            env.PROMOTE_IMAGE_TAG = imageTag

                            echo "Detected image: ${currentImage}"
                            echo "Extracted tag: ${env.PROMOTE_IMAGE_TAG}"
                        }

                        // Construct full image reference for target environment
                        // Assumes image follows pattern: registry/group/app-name:tag
                        env.PROMOTE_FULL_IMAGE = "${env.DEPLOY_REGISTRY}/${APP_GROUP}/${params.APP_NAME}:${env.PROMOTE_IMAGE_TAG}"
                        echo "Full image for promotion: ${env.PROMOTE_FULL_IMAGE}"
                    }
                }
            }
        }

        stage('Create Promotion MR') {
            steps {
                container('pipeline') {
                    script {
                        echo "=== Create Promotion MR: ${params.SOURCE_ENV} -> ${params.TARGET_ENV} ==="

                        withCredentials([
                            usernamePassword(credentialsId: 'gitlab-credentials',
                                              usernameVariable: 'GIT_USERNAME',
                                              passwordVariable: 'GIT_PASSWORD'),
                            string(credentialsId: 'gitlab-token-secret', variable: 'GITLAB_TOKEN')
                        ]) {
                            // Phase 1: Clone requires global credential helper (repo doesn't exist yet)
                            loadHelpers().withGitCredentials {
                                sh """
                                    rm -rf k8s-deployments
                                    git clone ${DEPLOYMENT_REPO} k8s-deployments
                                """
                            }
                            // Phase 2: All subsequent operations use repo-scoped config
                            loadHelpers().withGitCredentials('k8s-deployments') {
                                // Push feature branch and create merge request
                                def mrDescription = """## Promotion from ${params.SOURCE_ENV.capitalize()}

**Application**: ${params.APP_NAME}
**Image Tag**: ${env.PROMOTE_IMAGE_TAG}
**Source Environment**: ${params.SOURCE_ENV}
**Target Environment**: ${params.TARGET_ENV}
**Build**: ${env.BUILD_URL}

### Changes

This merge request promotes ${params.APP_NAME} from ${params.SOURCE_ENV} to ${params.TARGET_ENV}.

**Image**: ${env.PROMOTE_FULL_IMAGE}

### Promotion Path

${params.SOURCE_ENV == 'dev' ? '- [x] dev (current)\n- [ ] stage (this promotion)\n- [ ] prod' : '- [x] dev\n- [x] stage (current)\n- [ ] prod (this promotion)'}

### Deployment

Once this MR is merged, ArgoCD will automatically deploy to the ${params.TARGET_ENV} namespace.

${params.TARGET_ENV == 'prod' ? '> **Production Deployment** - Please review carefully before merging.' : ''}

---
*Generated by Jenkins Promote Pipeline*"""

                                // Write MR description to temp file (multi-line content can break withEnv)
                                def mrDescriptionFile = helpers.tempFilePath('mr-description', '.txt')
                                writeFile file: mrDescriptionFile, text: mrDescription

                                def prefix = promoteBranchPrefix()
                                withEnv(["PROMOTE_BRANCH_PREFIX=${prefix}"]) {
                                    sh "./scripts/pipeline promote-flow --mode manual --source-env ${params.SOURCE_ENV} --target-env ${params.TARGET_ENV} --app-name ${params.APP_NAME} --image-tag ${env.PROMOTE_IMAGE_TAG} --full-image ${env.PROMOTE_FULL_IMAGE} --mr-description-file ${mrDescriptionFile}"
                                }

                                echo "[${params.TARGET_ENV.toUpperCase()}] Promotion MR created successfully: ${prefix}${params.TARGET_ENV}-${env.PROMOTE_IMAGE_TAG} â†’ ${params.TARGET_ENV}"
                            }
                        }
                    }
                }
            }
        }
    }

    post {
        success {
            echo """
=======================================================
PROMOTION MR CREATED SUCCESSFULLY
=======================================================
Application: ${params.APP_NAME}
Source: ${params.SOURCE_ENV}
Target: ${params.TARGET_ENV}
Image Tag: ${env.PROMOTE_IMAGE_TAG}
Image: ${env.PROMOTE_FULL_IMAGE}
Build URL: ${env.BUILD_URL}
=======================================================

Next steps:
1. Review the merge request in GitLab
2. Merge to deploy to ${params.TARGET_ENV}
3. ArgoCD will automatically sync the deployment
=======================================================
"""
        }
        failure {
            echo """
=======================================================
PROMOTION FAILED
=======================================================
Application: ${params.APP_NAME}
Source: ${params.SOURCE_ENV}
Target: ${params.TARGET_ENV}
Build URL: ${env.BUILD_URL}
Check logs above for error details
=======================================================
"""
        }
        always {
            container('pipeline') {
                script {
                    // Cleanup temporary files and credentials
                    sh '''
                        echo "Performing cleanup..."
                        rm -rf k8s-deployments || true
                        echo "Cleanup completed"
                    '''
                    loadHelpers().cleanupWorkspaceFiles(['.mr-description-*'])
                }
            }
        }
    }
}
