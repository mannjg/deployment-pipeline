// Simplified k8s-deployments Pipeline
// Single workflow that handles all branches:
// - Feature branches: validate CUE, generate manifests, commit back
// - Environment branches (dev/stage/prod): + deploy via ArgoCD + auto-promote
//
// Pre-merge validation works via GitLab commit status - MRs are blocked
// until the source branch build passes.

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Waits for ArgoCD application to sync and become healthy
 * @param appName ArgoCD application name
 * @param timeoutSeconds Maximum time to wait (default: 300)
 * @return true if sync successful and healthy, false otherwise
 */
def waitForArgoCDSync(String appName, int timeoutSeconds = 300) {
    container('pipeline') {
        script {
            echo "Waiting for ${appName} to sync and become healthy..."

            sh """
                # Wait for sync with timeout
                argocd app wait ${appName} \
                    --timeout ${timeoutSeconds} \
                    --health \
                    --sync || {
                    echo "ERROR: ${appName} failed to sync or become healthy"

                    # Show app status for debugging
                    argocd app get ${appName}

                    exit 1
                }

                echo "${appName} synced and healthy"
            """
        }
    }
}

/**
 * Creates a promotion MR to the next environment
 * Performs semantic merge: promotes app config, preserves env-specific fields
 * @param sourceEnv Source environment (dev or stage)
 */
def createPromotionMR(String sourceEnv) {
    container('pipeline') {
        script {
            // Determine target environment
            def targetEnv = ''
            if (sourceEnv == 'dev') {
                targetEnv = 'stage'
            } else if (sourceEnv == 'stage') {
                targetEnv = 'prod'
            } else {
                echo "No promotion needed from ${sourceEnv}"
                return
            }

            echo "=== Creating Promotion MR: ${sourceEnv} -> ${targetEnv} ==="

            withCredentials([
                usernamePassword(credentialsId: 'gitlab-credentials',
                                usernameVariable: 'GIT_USERNAME',
                                passwordVariable: 'GIT_PASSWORD'),
                string(credentialsId: 'gitlab-api-token-secret', variable: 'GITLAB_TOKEN')
            ]) {
                sh '''
                    # Setup git credentials
                    git config --global user.name "Jenkins CI"
                    git config --global user.email "jenkins@local"
                    git config --global credential.helper '!f() { printf "username=%s\\npassword=%s\\n" "${GIT_USERNAME}" "${GIT_PASSWORD}"; }; f'
                '''

                sh """
                    # Fetch target branch
                    git fetch origin ${targetEnv}

                    # Create promotion branch from target
                    TIMESTAMP=\$(date +%Y%m%d-%H%M%S)
                    PROMOTION_BRANCH="promote-${targetEnv}-\${TIMESTAMP}"

                    git checkout -B ${targetEnv} origin/${targetEnv}
                    git checkout -b "\${PROMOTION_BRANCH}"

                    # Promote app config from source to target
                    # This performs semantic merge: app config from source,
                    # env-specific fields (namespace, replicas, etc.) preserved from target
                    ./scripts/promote-app-config.sh ${sourceEnv} ${targetEnv} || {
                        echo "ERROR: App config promotion failed"
                        exit 1
                    }

                    # Regenerate manifests with promoted config
                    ./scripts/generate-manifests.sh ${targetEnv} || {
                        echo "ERROR: Manifest generation failed"
                        exit 1
                    }

                    # Check if there are any changes to commit
                    if git diff --quiet && git diff --cached --quiet; then
                        echo "No changes to promote - config already in sync"
                        exit 0
                    fi

                    # Commit changes
                    git add -A
                    git commit -m "Promote ${sourceEnv} to ${targetEnv}

Automated promotion after successful ${sourceEnv} deployment.

This MR promotes app-specific configuration while preserving
environment-specific settings (namespace, replicas, resources).

Review the changes below and revert any that should not be promoted.

Source: ${sourceEnv}
Target: ${targetEnv}
Build: ${env.BUILD_URL}"

                    # Push promotion branch
                    git push -u origin "\${PROMOTION_BRANCH}"

                    # Create MR using GitLab API
                    export GITLAB_URL_INTERNAL="${env.GITLAB_URL}"

                    ./scripts/create-gitlab-mr.sh \\
                        "\${PROMOTION_BRANCH}" \\
                        "${targetEnv}" \\
                        "Promote ${sourceEnv} to ${targetEnv}" \\
                        "Automated promotion MR after successful ${sourceEnv} deployment.

## What's Promoted (App-Specific)
- Container images (CI/CD managed)
- Application environment variables
- ConfigMap data
- Other app-level configuration

## What's Preserved (Environment-Specific)
- Namespace: ${targetEnv}
- Replicas, resources, debug flags

## Review Instructions
1. Review the diff below
2. **Revert any changes that should NOT be promoted** (e.g., dev-specific debug settings)
3. Approve and merge when ready

---
**Source:** ${sourceEnv}
**Target:** ${targetEnv}
**Jenkins Build:** ${env.BUILD_URL}

Auto-generated by k8s-deployments CI/CD pipeline"

                    echo "Created promotion MR: \${PROMOTION_BRANCH} -> ${targetEnv}"
                """

                // Cleanup git credentials
                sh 'git config --global --unset credential.helper || true'
            }
        }
    }
}

// ============================================================================
// MAIN PIPELINE
// ============================================================================

// Agent image from environment (ConfigMap) - required, no fallback
def agentImage = System.getenv('JENKINS_AGENT_IMAGE')
if (!agentImage) {
    error "JENKINS_AGENT_IMAGE environment variable is required but not set. Configure it in the pipeline-config ConfigMap."
}

pipeline {
    agent {
        kubernetes {
            yaml """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: pipeline
    image: ${agentImage}
    command:
    - cat
    tty: true
    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "1Gi"
        cpu: "1000m"
"""
        }
    }

    options {
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '30', daysToKeepStr: '60'))
        disableConcurrentBuilds()
    }

    environment {
        // GitLab configuration (from pipeline-config ConfigMap)
        GITLAB_URL = System.getenv('GITLAB_URL_INTERNAL')
        GITLAB_GROUP = System.getenv('GITLAB_GROUP')
        DEPLOYMENTS_REPO = System.getenv('DEPLOYMENTS_REPO_URL')

        // ArgoCD configuration
        ARGOCD_SERVER = 'argocd-server.argocd.svc.cluster.local:80'
        ARGOCD_OPTS = '--plaintext --grpc-web'

        // Environment branches
        ENV_BRANCHES = 'dev,stage,prod'
        PROMOTE_BRANCHES = 'dev,stage'
    }

    stages {
        stage('Validate & Generate Manifests') {
            steps {
                container('pipeline') {
                    script {
                        echo """
=======================================================
k8s-deployments CI/CD Pipeline
=======================================================
Branch: ${env.BRANCH_NAME}
Build: ${env.BUILD_URL}
=======================================================
"""

                        // Validate required environment variables
                        if (!env.GITLAB_URL) {
                            error "GITLAB_URL_INTERNAL not set. Configure pipeline-config ConfigMap."
                        }

                        // Check if env.cue exists (environment branches have it)
                        def hasEnvCue = fileExists('env.cue')
                        if (!hasEnvCue) {
                            echo "No env.cue found - this is main or a feature branch without environment context"
                            echo "Skipping manifest generation"
                            env.HAS_ENV_CUE = 'false'
                            return
                        }

                        env.HAS_ENV_CUE = 'true'

                        // Validate CUE configuration
                        echo "Validating CUE configuration..."
                        sh '''
                            if [ -x "./scripts/validate-cue-config.sh" ]; then
                                ./scripts/validate-cue-config.sh || {
                                    echo "CUE validation failed"
                                    exit 1
                                }
                            else
                                # Fallback: validate env.cue only
                                cue vet ./env.cue || {
                                    echo "CUE validation failed"
                                    exit 1
                                }
                            fi
                            echo "CUE configuration is valid"
                        '''

                        // Generate manifests
                        echo "Generating manifests..."
                        sh '''
                            ./scripts/generate-manifests.sh || {
                                echo "Manifest generation failed"
                                exit 1
                            }
                            echo "Manifest generation completed"
                        '''

                        // Commit and push generated manifests back to branch
                        withCredentials([
                            usernamePassword(credentialsId: 'gitlab-credentials',
                                            usernameVariable: 'GIT_USERNAME',
                                            passwordVariable: 'GIT_PASSWORD')
                        ]) {
                            sh '''
                                git config --global user.name "Jenkins CI"
                                git config --global user.email "jenkins@local"
                                git config --global credential.helper '!f() { printf "username=%s\\npassword=%s\\n" "${GIT_USERNAME}" "${GIT_PASSWORD}"; }; f'
                            '''

                            sh """
                                # Check if manifests changed
                                if git diff --quiet manifests/; then
                                    echo "No manifest changes to commit"
                                else
                                    echo "Committing generated manifests..."
                                    git add manifests/
                                    git commit -m "chore: regenerate manifests [jenkins-ci]

Generated by Jenkins CI.
Build: ${env.BUILD_URL}"
                                    git push origin HEAD:\${GIT_BRANCH#origin/}
                                    echo "Manifests committed and pushed"
                                fi

                                # Cleanup credentials
                                git config --global --unset credential.helper || true
                            """
                        }

                        echo "Validation and manifest generation complete"
                    }
                }
            }
        }

        stage('Deploy to Environment') {
            when {
                expression {
                    env.BRANCH_NAME in env.ENV_BRANCHES.split(',') && env.HAS_ENV_CUE == 'true'
                }
            }
            stages {
                stage('Login to ArgoCD') {
                    steps {
                        container('pipeline') {
                            script {
                                echo "=== Logging into ArgoCD ==="

                                withCredentials([
                                    usernamePassword(credentialsId: 'argocd-credentials',
                                                    usernameVariable: 'ARGOCD_USERNAME',
                                                    passwordVariable: 'ARGOCD_PASSWORD')
                                ]) {
                                    sh """
                                        argocd login ${env.ARGOCD_SERVER} \
                                            --username \${ARGOCD_USERNAME} \
                                            --password \${ARGOCD_PASSWORD} \
                                            ${env.ARGOCD_OPTS}

                                        echo "Logged into ArgoCD"
                                    """
                                }
                            }
                        }
                    }
                }

                stage('Refresh & Sync ArgoCD') {
                    steps {
                        container('pipeline') {
                            script {
                                def environment = env.BRANCH_NAME
                                def appName = "example-app-${environment}"

                                echo "=== Refreshing ArgoCD Application: ${appName} ==="

                                sh """
                                    # Refresh the app (reload from Git)
                                    argocd app get ${appName} --refresh || {
                                        echo "WARNING: Failed to refresh ${appName}"
                                        exit 1
                                    }

                                    echo "Refreshed ${appName}"
                                """
                            }
                        }
                    }
                }

                stage('Wait for Sync & Health') {
                    steps {
                        script {
                            def environment = env.BRANCH_NAME
                            def appName = "example-app-${environment}"

                            waitForArgoCDSync(appName, 300)
                        }
                    }
                }

                stage('Deployment Summary') {
                    steps {
                        container('pipeline') {
                            script {
                                echo """
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
DEPLOYMENT SUCCESSFUL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Environment: ${env.BRANCH_NAME}

Application has been:
  - Refreshed in ArgoCD
  - Synced to latest Git state
  - Verified as healthy

Build: ${env.BUILD_URL}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""
                            }
                        }
                    }
                }
            }
        }

        stage('Create Promotion MR') {
            when {
                expression {
                    env.BRANCH_NAME in env.PROMOTE_BRANCHES.split(',') && env.HAS_ENV_CUE == 'true'
                }
            }
            steps {
                script {
                    createPromotionMR(env.BRANCH_NAME)
                }
            }
        }
    }

    post {
        success {
            script {
                echo """
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PIPELINE COMPLETED SUCCESSFULLY
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Branch: ${env.BRANCH_NAME}
Build: ${env.BUILD_URL}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""

                // Update GitLab commit status
                container('pipeline') {
                    withCredentials([string(credentialsId: 'gitlab-api-token-secret', variable: 'GITLAB_TOKEN')]) {
                        sh """
                            curl -s -X POST \
                                -H "PRIVATE-TOKEN: \${GITLAB_TOKEN}" \
                                -H "Content-Type: application/json" \
                                -d '{
                                    "state": "success",
                                    "description": "Pipeline passed",
                                    "context": "jenkins/k8s-deployments",
                                    "target_url": "${env.BUILD_URL}"
                                }' \
                                "${env.GITLAB_URL}/api/v4/projects/${env.GITLAB_GROUP ?: 'p2c'}%2Fk8s-deployments/statuses/\$(git rev-parse HEAD)" \
                                || echo "Could not update commit status"
                        """
                    }
                }
            }
        }

        failure {
            script {
                echo """
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PIPELINE FAILED
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Branch: ${env.BRANCH_NAME}
Build: ${env.BUILD_URL}

Check logs above for error details.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""

                // Update GitLab commit status
                container('pipeline') {
                    withCredentials([string(credentialsId: 'gitlab-api-token-secret', variable: 'GITLAB_TOKEN')]) {
                        sh """
                            curl -s -X POST \
                                -H "PRIVATE-TOKEN: \${GITLAB_TOKEN}" \
                                -H "Content-Type: application/json" \
                                -d '{
                                    "state": "failed",
                                    "description": "Pipeline failed",
                                    "context": "jenkins/k8s-deployments",
                                    "target_url": "${env.BUILD_URL}"
                                }' \
                                "${env.GITLAB_URL}/api/v4/projects/${env.GITLAB_GROUP ?: 'p2c'}%2Fk8s-deployments/statuses/\$(git rev-parse HEAD)" \
                                || echo "Could not update commit status"
                        """
                    }
                }
            }
        }

        always {
            sh 'echo "Pipeline cleanup completed"'
        }
    }
}
