import groovy.transform.Field

@Field static final String UPDATE_BRANCH_PREFIX = 'update-'
@Field static final String PROMOTE_BRANCH_PREFIX = 'promote-'
@Field static final String GITLAB_STATUS_CONTEXT = 'jenkins/k8s-deployments'
@Field static final List<String> ENV_BRANCHES = ['dev', 'stage', 'prod']
@Field static final List<String> PROMOTE_BRANCHES = ['dev', 'stage']

@Field def helpers = null

def loadHelpers() {
    if (helpers == null) {
        helpers = load 'Jenkinsfile.helpers.groovy'
    }
    return helpers
}

// Agent image from system environment (set via ConfigMap envFrom).
// System.getenv() is required here because this runs at Groovy parse time,
// before the pipeline environment block is evaluated.
def getAgentImageOrFail(String envVarName = 'JENKINS_AGENT_IMAGE') {
    def agentImage = System.getenv(envVarName)
    if (!agentImage) {
        error "${envVarName} not set - check pipeline-config ConfigMap"
    }
    return agentImage
}

def podTemplateYaml(String agentImage) {
    return """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: pipeline
    image: ${agentImage}
    command:
    - cat
    tty: true
    env:
    - name: DOCKER_HOST
      value: tcp://localhost:2375
    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "1Gi"
        cpu: "1000m"
  - name: dind
    image: docker:dind
    securityContext:
      privileged: true
    env:
    - name: DOCKER_TLS_CERTDIR
      value: ""
    args:
    - --insecure-registry=${env.CONTAINER_REGISTRY_EXTERNAL?.replaceAll('^https?://', '')}
    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "2Gi"
        cpu: "1000m"
"""
}

// k8s-deployments Pipeline
//
// Two distinct workflows:
// 1. Feature branches (with open MR): validate CUE, generate manifests, commit back, validate, dry-run
// 2. Environment branches (post-merge): validate CUE, validate existing manifests, dry-run, deploy, auto-promote
//
// Key principle: Manifests are generated ONLY in feature branches (pre-merge).
// Environment branches receive manifests via merge - no regeneration needed.

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Determines the target environment from a branch name.
 * - Environment branches (dev, stage, prod) return themselves
 * - Feature branches return their target environment based on naming convention:
 *   - update-dev-* → dev
 *   - promote-stage-* → stage
 *   - promote-prod-* → prod
 * @param branchName The branch name to analyze
 * @return The target environment (dev, stage, or prod) or null if unknown
 */
def getTargetEnvironment(String branchName) {
    // Direct environment branches
    if (branchName in ENV_BRANCHES) {
        return branchName
    }
    // Feature branches targeting dev (from app CI)
    if (branchName.startsWith("${UPDATE_BRANCH_PREFIX}dev-")) {
        return 'dev'
    }
    // Promotion branches
    if (branchName.startsWith("${PROMOTE_BRANCH_PREFIX}stage-")) {
        return 'stage'
    }
    if (branchName.startsWith("${PROMOTE_BRANCH_PREFIX}prod-")) {
        return 'prod'
    }
    // Unknown branch pattern
    return null
}

/**
 * Queries GitLab API to find open MRs for a branch and returns the target environment.
 * This enables MR-preview manifest generation: branches can generate manifests
 * using the target environment's env.cue when an MR exists.
 *
 * Requires GITLAB_TOKEN and GITLAB_URL as shell env vars (caller wraps in withCredentials).
 *
 * @param branchName The source branch name
 * @param projectPath GitLab project path (e.g., "p2c/k8s-deployments")
 * @return The target environment (dev, stage, or prod) if MR exists, null otherwise
 */
def getMRTargetEnvironment(String branchName, String projectPath) {
    // Skip main/master - these are source of truth branches
    if (branchName in ['main', 'master']) {
        return null
    }

    // Guard: GITLAB_URL must be set (from pipeline environment block)
    // Note: GITLAB_TOKEN is withCredentials-scoped (shell-only) and cannot be checked from Groovy
    if (!env.GITLAB_URL) {
        echo "Warning: GITLAB_URL not set - cannot query GitLab MRs"
        return null
    }

    def isEnvBranch = branchName in ENV_BRANCHES

    try {
        def encodedProject = projectPath.replace('/', '%2F')

        // Scope Groovy locals as env vars for sh ''' blocks (not global env.*)
        def targetBranch = withEnv([
            "MR_QUERY_PROJECT=${encodedProject}",
            "MR_QUERY_BRANCH=${branchName}"
        ]) {
            sh(
                script: '''
                    ./scripts/gitlab-api.sh GET \
                        "${GITLAB_URL}/api/v4/projects/${MR_QUERY_PROJECT}/merge_requests?state=opened&source_branch=${MR_QUERY_BRANCH}" \
                        2>/dev/null | jq -r '.[0].target_branch // empty'
                ''',
                returnStdout: true
            ).trim()
        }

        // Only return if target is an environment branch
        if (targetBranch in ENV_BRANCHES) {
            // For env-to-env MRs, only process if target is DIFFERENT from source
            if (isEnvBranch && targetBranch == branchName) {
                echo "Skipping self-referential MR for ${branchName}"
                return null
            }
            def mrType = isEnvBranch ? "env-to-env promotion" : "feature branch"
            echo "Found open MR (${mrType}) targeting ${targetBranch} for branch ${branchName}"
            return targetBranch
        }
    } catch (Exception e) {
        echo "Warning: Could not query MRs for ${branchName}: ${e.message}"
    }

    return null
}

/**
 * Merges the target environment branch into the current feature branch for MR-preview.
 * Delegates to scripts/merge-preview.sh for conflict resolution logic.
 *
 * @param targetEnv The target environment branch (dev, stage, or prod)
 * @param isPromoteBranch Whether this is a promote-* branch
 * @return true if merge was successful, false otherwise
 */
def mergeTargetBranchForPreview(String targetEnv, boolean isPromoteBranch = false) {
    try {
        sh "./scripts/merge-preview.sh ${isPromoteBranch ? '--promote ' : ''}${targetEnv}"
        return true
    } catch (Exception e) {
        echo "Warning: Could not merge ${targetEnv}: ${e.message}"
        return false
    }
}

/**
 * Validates manifest YAML files using static checks and server-side dry-run
 * @param targetEnv The target environment (dev, stage, or prod)
 * @return true if validation passes, false otherwise
 */
def validateManifests(String targetEnv) {
    container('pipeline') {
        script {
            echo "=== Validating Manifests for ${targetEnv} ==="

            // Static validation (YAML syntax, required fields, security checks)
            echo "Running static manifest validation..."
            sh "./scripts/pipeline validate-manifests-static ${targetEnv}"
            echo "Static validation passed"

            // Server-side dry-run validation against the cluster
            // Note: Manifests are organized by app name (manifests/exampleApp/, manifests/postgres/),
            // not by environment. The environment is baked into the manifest content via CUE.
            echo "Running server-side dry-run validation..."
            sh "./scripts/pipeline validate-manifests-dry-run"
        }
    }
}

/**
 * Waits for ArgoCD application to sync and become healthy
 * @param appName ArgoCD application name
 * @param timeoutSeconds Maximum time to wait (default: 300)
 */
def waitForArgoCDSync(String appName, int timeoutSeconds = 300) {
    container('pipeline') {
        script {
            echo "Waiting for ${appName} to sync and become healthy..."

            sh "./scripts/pipeline argocd-wait ${appName} ${timeoutSeconds}"
        }
    }
}

/**
 * Closes stale open promotion MRs targeting the given environment.
 * New promotions always supersede old ones - prevents orphaned MR accumulation.
 * Requires GITLAB_TOKEN and GITLAB_URL from caller's withCredentials/environment scope.
 * @param encodedProject URL-encoded GitLab project path (e.g., "p2c%2Fk8s-deployments")
 * @param targetEnv Target environment branch (stage or prod)
 */
def closeStalePromotionMRs(String encodedProject, String targetEnv) {
    withEnv([
        "PROMO_ENCODED_PROJECT=${encodedProject}",
        "PROMO_TARGET=${targetEnv}",
        "PROMO_PREFIX=${PROMOTE_BRANCH_PREFIX}"
    ]) {
        sh './scripts/pipeline close-stale-promotion-mrs'
    }
}

/**
 * Extracts the current image reference from a source environment's env.cue via GitLab API.
 * Requires GITLAB_TOKEN and GITLAB_URL from caller's withCredentials/environment scope.
 * @param encodedProject URL-encoded GitLab project path
 * @param sourceEnv Source environment branch (dev or stage)
 * @return Full image reference string (e.g., "registry/group/example-app:1.0.0-SNAPSHOT-abc123")
 */
def extractSourceImageTag(String encodedProject, String sourceEnv) {
    return withEnv([
        "PROMO_ENCODED_PROJECT=${encodedProject}",
        "PROMO_SOURCE=${sourceEnv}"
    ]) {
        sh(
            script: '''
                ./scripts/gitlab-api.sh GET \
                    "${GITLAB_URL}/api/v4/projects/${PROMO_ENCODED_PROJECT}/repository/files/env.cue?ref=${PROMO_SOURCE}" \
                    2>/dev/null | jq -r '.content' | base64 -d | grep 'image:' | sed -E 's/.*image:\\s*"([^"]+)".*/\\1/' | head -1
            ''',
            returnStdout: true
        ).trim()
    }
}

/**
 * Promotes Maven and Docker artifacts from source to target environment.
 * Runs promote-artifact.sh and returns the new image tag.
 * Requires NEXUS_USER, NEXUS_PASSWORD, GITLAB_TOKEN from caller's withCredentials scope.
 * @param sourceEnv Source environment (dev or stage)
 * @param targetEnv Target environment (stage or prod)
 * @param gitHash Git commit hash extracted from source image tag
 * @return New image tag for the target environment
 */
def promoteArtifacts(String sourceEnv, String targetEnv, String gitHash) {
    def promoteRc = sh(
        script: "./scripts/pipeline promote-artifacts ${sourceEnv} ${targetEnv} ${gitHash}",
        returnStatus: true
    )

    if (promoteRc != 0) {
        echo "Artifact promotion output:"
        sh "cat \${WORKSPACE}/promote.log || true"
        error "Artifact promotion failed - cannot create promotion MR without valid image tag. If release version already exists in Nexus, bump the version in pom.xml."
    }

    def newImageTag = readFile("${env.WORKSPACE}/promoted-image-tag").trim()
    echo "New image tag for ${targetEnv}: ${newImageTag}"
    return newImageTag
}

/**
 * Creates a promotion branch, promotes app config, generates manifests, and creates a GitLab MR.
 * Must be called within withGitCredentials and withCredentials (for GITLAB_TOKEN).
 * @param sourceEnv Source environment (dev or stage)
 * @param targetEnv Target environment (stage or prod)
 * @param imageTag Image tag from source environment (used for branch naming and config promotion)
 * @param newImageTag Promoted image tag (from promoteArtifacts), or empty string to skip image override
 */
def createPromotionBranchAndMR(String sourceEnv, String targetEnv, String imageTag, String newImageTag) {
    def h = loadHelpers()
    h.cleanupWorkspaceFiles(['promoted-image-tag', 'promote.log'])
    sh "./scripts/pipeline create-promotion-branch-mr ${sourceEnv} ${targetEnv} ${imageTag} ${newImageTag}"
}

/**
 * Creates a promotion MR to the next environment.
 * Orchestrates: close stale MRs -> extract image -> promote artifacts -> create branch + MR.
 * @param sourceEnv Source environment (dev or stage)
 */
def createPromotionMR(String sourceEnv) {
    container('pipeline') {
        script {
            def targetEnv = sourceEnv == 'dev' ? 'stage' : sourceEnv == 'stage' ? 'prod' : null
            if (!targetEnv) {
                echo "No promotion needed from ${sourceEnv}"
                return
            }

            echo "=== Creating Promotion MR: ${sourceEnv} -> ${targetEnv} ==="

            def projectPath = "${env.GITLAB_GROUP}/k8s-deployments"
            def encodedProject = projectPath.replace('/', '%2F')

            withCredentials([
                usernamePassword(credentialsId: 'gitlab-credentials',
                                usernameVariable: 'GIT_USERNAME',
                                passwordVariable: 'GIT_PASSWORD'),
                string(credentialsId: 'gitlab-token-secret', variable: 'GITLAB_TOKEN'),
                usernamePassword(credentialsId: 'maven-repo-credentials',
                                usernameVariable: 'NEXUS_USER',
                                passwordVariable: 'NEXUS_PASSWORD')
            ]) {
                closeStalePromotionMRs(encodedProject, targetEnv)

                def sourceImageTag = extractSourceImageTag(encodedProject, sourceEnv)
                def imageTag = sourceImageTag.contains(':') ? sourceImageTag.split(':').last() : sourceImageTag

                def gitHash = sh(
                    script: "echo '${imageTag}' | grep -oE '[a-f0-9]{6,}\$' || echo ''",
                    returnStdout: true
                ).trim()

                if (!gitHash) {
                    echo "WARNING: Could not extract git hash from source image tag: ${sourceImageTag}"
                    echo "Skipping artifact promotion - MR will use existing image version"
                }

                echo "Source image tag: ${imageTag}"
                echo "Git hash: ${gitHash}"

                def newImageTag = ''
                if (gitHash) {
                    newImageTag = promoteArtifacts(sourceEnv, targetEnv, gitHash)
                }

                if (!imageTag) {
                    error "Cannot create promotion MR: no image tag found in ${sourceEnv} env.cue"
                }

                helpers.withGitCredentials('.') {
                    createPromotionBranchAndMR(sourceEnv, targetEnv, imageTag, newImageTag)
                }
            }
        }
    }
}

// ============================================================================
// MAIN PIPELINE
// ============================================================================

// Agent image from system environment (set via ConfigMap envFrom).
// System.getenv() is required here because this runs at Groovy parse time,
// before the pipeline environment block is evaluated.
def agentImage = getAgentImageOrFail()

pipeline {
    agent {
        kubernetes {
            yaml podTemplateYaml(agentImage)
        }
    }

    options {
        timestamps()
        ansiColor('xterm')
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '30', daysToKeepStr: '60'))
        disableConcurrentBuilds()
    }

    environment {
        // These reference environment variables set by the pipeline-config ConfigMap
        GITLAB_URL = "${env.GITLAB_URL_INTERNAL ?: ''}"
        GITLAB_GROUP = "${env.GITLAB_GROUP ?: ''}"
        DEPLOYMENTS_REPO = "${env.DEPLOYMENTS_REPO_URL ?: ''}"
        // External container registry (HTTPS) for image operations
        CONTAINER_REGISTRY_EXTERNAL = "${env.CONTAINER_REGISTRY_EXTERNAL ?: ''}"
        // Container registry path prefix (e.g., 'p2c' for registry-dso.jmann.local/p2c/...)
        CONTAINER_REGISTRY_PATH_PREFIX = "${env.CONTAINER_REGISTRY_PATH_PREFIX ?: ''}"
        // Maven repository URL for artifact promotion
        MAVEN_REPO_URL_INTERNAL = "${env.MAVEN_REPO_URL_INTERNAL ?: ''}"
        ARGOCD_SERVER = "${env.ARGOCD_SERVER ?: ''}"
        ARGOCD_OPTS = "${env.ARGOCD_OPTS ?: ''}"
    }

    stages {
        stage('Initialize') {
            steps {
                container('pipeline') {
                    script {
                        echo """
=======================================================
k8s-deployments CI/CD Pipeline
=======================================================
Branch: ${env.BRANCH_NAME}
Build: ${env.BUILD_URL}
=======================================================
"""
                        // Validate required environment variables from ConfigMap
                        loadHelpers().validateRequiredEnvVars(['JENKINS_AGENT_IMAGE', 'GITLAB_URL_INTERNAL', 'GITLAB_GROUP', 'CONTAINER_REGISTRY_EXTERNAL', 'CONTAINER_REGISTRY_PATH_PREFIX'])

                        env.ORIGINAL_COMMIT_SHA = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
                        echo "Commit SHA: ${env.ORIGINAL_COMMIT_SHA}"

                        // JENKINS-20: Skip redundant builds triggered by manifest push
                        // The Generate Manifests stage pushes [jenkins-ci] commits back to feature
                        // branches, which triggers the webhook again. Detect and skip these.
                        if (env.BRANCH_NAME && !(env.BRANCH_NAME in ENV_BRANCHES)) {
                            def lastCommitMsg = sh(script: 'git log -1 --pretty=%B', returnStdout: true).trim()
                            if (lastCommitMsg.contains('[jenkins-ci]')) {
                                currentBuild.result = 'NOT_BUILT'
                                currentBuild.description = 'Skipped: CI-generated commit'
                                echo "Skipping build: last commit is CI-generated ([jenkins-ci] marker found)"
                                return
                            }
                        }

                        // Check for [no-promote] flag in the current merge only
                        // For merge commits: check commits from the merged branch (HEAD^1..HEAD^2)
                        // For direct pushes: check just HEAD
                        // This ensures historical [no-promote] commits don't affect new merges
                        def commitMessages = ''
                        def isMergeCommit = sh(script: 'git rev-parse HEAD^2 >/dev/null 2>&1 && echo "true" || echo "false"', returnStdout: true).trim()
                        if (isMergeCommit == 'true') {
                            // Get commits from the merged branch only
                            commitMessages = sh(script: 'git log HEAD^1..HEAD^2 --pretty=%B', returnStdout: true).trim()
                            // Also check the merge commit message itself
                            def mergeMsg = sh(script: 'git log -1 --pretty=%B', returnStdout: true).trim()
                            commitMessages = mergeMsg + "\n" + commitMessages
                            echo "Merge commit detected - checking merged branch commits for [no-promote]"
                        } else {
                            commitMessages = sh(script: 'git log -1 --pretty=%B', returnStdout: true).trim()
                            echo "Direct push detected - checking HEAD commit for [no-promote]"
                        }
                        // Check for [no-promote] flag OR revert commits (rollbacks shouldn't cascade)
                        def isRevert = commitMessages.startsWith('Revert "') || commitMessages.contains('\nRevert "')
                        env.NO_PROMOTE = (commitMessages.contains('[no-promote]') || isRevert) ? 'true' : 'false'
                        if (env.NO_PROMOTE == 'true') {
                            if (isRevert) {
                                echo "INFO: Revert commit detected - skipping promotion MR creation (rollbacks don't cascade)"
                            } else {
                                echo "INFO: [no-promote] flag detected - skipping promotion MR creation"
                            }
                        }

                        // Determine branch type and MR status
                        env.IS_ENV_BRANCH = (env.BRANCH_NAME in ENV_BRANCHES) ? 'true' : 'false'
                        env.HAS_OPEN_MR = 'false'
                        env.MR_TARGET_ENV = ''

                        withCredentials([string(credentialsId: 'gitlab-token-secret', variable: 'GITLAB_TOKEN')]) {
                            def projectPath = "${env.GITLAB_GROUP}/k8s-deployments"
                            def mrTarget = getMRTargetEnvironment(env.BRANCH_NAME, projectPath)
                            if (mrTarget) {
                                env.HAS_OPEN_MR = 'true'
                                env.MR_TARGET_ENV = mrTarget
                            }
                        }

                        // Determine target environment
                        def targetEnv = getTargetEnvironment(env.BRANCH_NAME)
                        if (env.HAS_OPEN_MR == 'true' && env.IS_ENV_BRANCH == 'false') {
                            targetEnv = env.MR_TARGET_ENV
                        }
                        env.TARGET_ENV = targetEnv ?: ''

                        echo """
Branch Type: ${env.IS_ENV_BRANCH == 'true' ? 'Environment' : 'Feature'}
Has Open MR: ${env.HAS_OPEN_MR}
Target Environment: ${env.TARGET_ENV ?: 'N/A'}
"""
                    }
                }
            }
        }

        stage('Prepare Merge Preview') {
            when {
                expression {
                    // Only for feature branches with open MRs (need to merge target for env.cue)
                    env.TARGET_ENV != '' && env.HAS_OPEN_MR == 'true' && env.IS_ENV_BRANCH == 'false'
                }
            }
            steps {
                container('pipeline') {
                    script {
                        echo "=== Preparing MR Preview: Merging ${env.MR_TARGET_ENV} ==="

                        def isPromoteBranch = env.BRANCH_NAME.startsWith(PROMOTE_BRANCH_PREFIX)
                        if (isPromoteBranch) {
                            echo "Promote branch detected - will preserve promoted image versions"
                        }

                        withCredentials([
                            usernamePassword(credentialsId: 'gitlab-credentials',
                                            usernameVariable: 'GIT_USERNAME',
                                            passwordVariable: 'GIT_PASSWORD')
                        ]) {
                            loadHelpers().withGitCredentials('.') {
                                if (!mergeTargetBranchForPreview(env.MR_TARGET_ENV, isPromoteBranch)) {
                                    error "Could not merge ${env.MR_TARGET_ENV} - cannot proceed"
                                }
                            }
                        }
                    }
                }
            }
        }

        stage('Validate CUE') {
            when {
                expression { env.TARGET_ENV != '' }
            }
            steps {
                container('pipeline') {
                    script {
                        // Pure validation - no side effects
                        echo "Validating CUE configuration..."
                        sh './scripts/pipeline validate-cue'
                    }
                }
            }
        }

        stage('Generate Manifests') {
            when {
                expression {
                    // Only generate manifests for feature branches with open MRs
                    // Environment branches receive manifests via merge - no regeneration
                    // Exclude promote-* branches - they carry already-generated manifests from source env
                    // (regenerating would cause feedback loop: build -> push -> webhook -> build)
                    env.TARGET_ENV != '' && env.HAS_OPEN_MR == 'true' && env.IS_ENV_BRANCH == 'false' &&
                    !env.BRANCH_NAME.startsWith(PROMOTE_BRANCH_PREFIX)
                }
            }
            steps {
                container('pipeline') {
                    script {
                        echo "Generating manifests for ${env.TARGET_ENV}..."
                        sh """
                            ./scripts/generate-manifests.sh ${env.TARGET_ENV} || {
                                echo "Manifest generation failed"
                                exit 1
                            }
                        """

                        // Commit and push manifests back to feature branch
                        withCredentials([
                            usernamePassword(credentialsId: 'gitlab-credentials',
                                            usernameVariable: 'GIT_USERNAME',
                                            passwordVariable: 'GIT_PASSWORD')
                        ]) {
                            loadHelpers().withGitCredentials('.') {
                                sh "./scripts/pipeline commit-generated-manifests"
                            }
                        }

                        // FINAL_COMMIT_SHA is only set after successful push.
                        // On push failure, the stage fails and post block falls back to
                        // ORIGINAL_COMMIT_SHA — which correctly reports status against
                        // the pre-manifest-generation commit.
                        env.FINAL_COMMIT_SHA = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
                    }
                }
            }
        }

        stage('Validate Manifests') {
            when {
                expression { env.TARGET_ENV != '' }
            }
            steps {
                script {
                    validateManifests(env.TARGET_ENV)
                }
            }
        }

        stage('Deploy to Environment') {
            when {
                expression {
                    // Only deploy for environment branches (post-merge)
                    env.IS_ENV_BRANCH == 'true' && env.TARGET_ENV != ''
                }
            }
            stages {
                stage('Login to ArgoCD') {
                    steps {
                        container('pipeline') {
                            script {
                                echo "=== Logging into ArgoCD ==="
                                withCredentials([
                                    usernamePassword(credentialsId: 'argocd-credentials',
                                                    usernameVariable: 'ARGOCD_USERNAME',
                                                    passwordVariable: 'ARGOCD_PASSWORD')
                                ]) {
                                    sh """
                                        argocd login ${env.ARGOCD_SERVER} \
                                            --username \${ARGOCD_USERNAME} \
                                            --password \${ARGOCD_PASSWORD} \
                                            ${env.ARGOCD_OPTS}
                                    """
                                }
                            }
                        }
                    }
                }

                stage('Refresh & Sync') {
                    steps {
                        container('pipeline') {
                            script {
                                def appName = "example-app-${env.BRANCH_NAME}"
                                echo "=== Refreshing ArgoCD Application: ${appName} ==="

                                sh """
                                    argocd app get ${appName} --refresh || {
                                        echo "WARNING: Failed to refresh ${appName}"
                                        exit 1
                                    }
                                """
                            }
                        }
                    }
                }

                stage('Wait for Health') {
                    steps {
                        script {
                            def appName = "example-app-${env.BRANCH_NAME}"
                            waitForArgoCDSync(appName, 300)
                        }
                    }
                }

                stage('Deployment Summary') {
                    steps {
                        container('pipeline') {
                            echo """
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
DEPLOYMENT SUCCESSFUL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Environment: ${env.BRANCH_NAME}
Build: ${env.BUILD_URL}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""
                        }
                    }
                }
            }
        }

        stage('Create Promotion MR') {
            when {
                expression {
                    // Only create promotion MR for dev/stage after successful deployment
                    // Skip if commit message contains [no-promote]
                    env.BRANCH_NAME in PROMOTE_BRANCHES &&
                    env.IS_ENV_BRANCH == 'true' &&
                    env.NO_PROMOTE != 'true'
                }
            }
            steps {
                script {
                    createPromotionMR(env.BRANCH_NAME)
                }
            }
        }
    }

    post {
        success {
            script {
                echo """
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PIPELINE COMPLETED SUCCESSFULLY
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Branch: ${env.BRANCH_NAME}
Build: ${env.BUILD_URL}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""
                container('pipeline') {
                    loadHelpers().reportGitLabStatus('success', GITLAB_STATUS_CONTEXT,
                        env.FINAL_COMMIT_SHA ?: env.ORIGINAL_COMMIT_SHA,
                        "${env.GITLAB_GROUP}/k8s-deployments")
                }
            }
        }

        failure {
            script {
                echo """
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PIPELINE FAILED
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Branch: ${env.BRANCH_NAME}
Check logs above for error details.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""
                container('pipeline') {
                    loadHelpers().reportGitLabStatus('failed', GITLAB_STATUS_CONTEXT,
                        env.FINAL_COMMIT_SHA ?: env.ORIGINAL_COMMIT_SHA,
                        "${env.GITLAB_GROUP}/k8s-deployments")
                }
            }
        }

        always {
            sh 'echo "Pipeline cleanup completed"'
        }
    }
}
