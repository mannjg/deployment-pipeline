// k8s-deployments Pipeline
//
// Two distinct workflows:
// 1. Feature branches (with open MR): validate CUE, generate manifests, commit back, validate, dry-run
// 2. Environment branches (post-merge): validate CUE, validate existing manifests, dry-run, deploy, auto-promote
//
// Key principle: Manifests are generated ONLY in feature branches (pre-merge).
// Environment branches receive manifests via merge - no regeneration needed.

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Determines the target environment from a branch name.
 * - Environment branches (dev, stage, prod) return themselves
 * - Feature branches return their target environment based on naming convention:
 *   - update-dev-* → dev
 *   - promote-stage-* → stage
 *   - promote-prod-* → prod
 * @param branchName The branch name to analyze
 * @return The target environment (dev, stage, or prod) or null if unknown
 */
def getTargetEnvironment(String branchName) {
    // Direct environment branches
    if (branchName in ['dev', 'stage', 'prod']) {
        return branchName
    }
    // Feature branches targeting dev (from app CI)
    if (branchName.startsWith('update-dev-')) {
        return 'dev'
    }
    // Promotion branches
    if (branchName.startsWith('promote-stage-')) {
        return 'stage'
    }
    if (branchName.startsWith('promote-prod-')) {
        return 'prod'
    }
    // Unknown branch pattern
    return null
}

/**
 * Queries GitLab API to find open MRs for a branch and returns the target environment.
 * This enables MR-preview manifest generation: branches can generate manifests
 * using the target environment's env.cue when an MR exists.
 *
 * @param branchName The source branch name
 * @param gitlabToken GitLab API token
 * @param gitlabUrl GitLab server URL
 * @param projectPath GitLab project path (e.g., "p2c/k8s-deployments")
 * @return The target environment (dev, stage, or prod) if MR exists, null otherwise
 */
def getMRTargetEnvironment(String branchName, String gitlabToken, String gitlabUrl, String projectPath) {
    // Skip main/master - these are source of truth branches
    if (branchName in ['main', 'master']) {
        return null
    }

    def isEnvBranch = branchName in ['dev', 'stage', 'prod']

    try {
        // URL-encode the project path
        def encodedProject = projectPath.replace('/', '%2F')

        // Query GitLab API for open MRs with this source branch
        def targetBranch = sh(
            script: """
                curl -sf -H "PRIVATE-TOKEN: ${gitlabToken}" \
                    "${gitlabUrl}/api/v4/projects/${encodedProject}/merge_requests?state=opened&source_branch=${branchName}" \
                    2>/dev/null | jq -r '.[0].target_branch // empty'
            """,
            returnStdout: true
        ).trim()

        // Only return if target is an environment branch
        if (targetBranch in ['dev', 'stage', 'prod']) {
            // For env-to-env MRs, only process if target is DIFFERENT from source
            if (isEnvBranch && targetBranch == branchName) {
                echo "Skipping self-referential MR for ${branchName}"
                return null
            }
            def mrType = isEnvBranch ? "env-to-env promotion" : "feature branch"
            echo "Found open MR (${mrType}) targeting ${targetBranch} for branch ${branchName}"
            return targetBranch
        }
    } catch (Exception e) {
        echo "Warning: Could not query MRs for ${branchName}: ${e.message}"
    }

    return null
}

/**
 * Merges the target environment branch into the current feature branch for MR-preview.
 * This ensures the feature branch has the latest env.cue from the target,
 * so that the generated manifests will merge cleanly when the MR is accepted.
 *
 * Conflict resolution strategy:
 * - For promote-* branches: keep OURS for env.cue and manifests (they have promoted versions)
 * - For other feature branches: take THEIRS for env.cue (we need target's config)
 * - Manifests: always keep OURS (they're derivative - will be regenerated if needed)
 * - Services: keep OURS (feature branch changes)
 *
 * @param targetEnv The target environment branch (dev, stage, or prod)
 * @param isPromoteBranch Whether this is a promote-* branch
 * @return true if merge was successful, false otherwise
 */
def mergeTargetBranchForPreview(String targetEnv, boolean isPromoteBranch = false) {
    try {
        sh """
            echo "Merging ${targetEnv} into feature branch for clean MR-preview..."
            git fetch origin ${targetEnv}

            # Configure git for merge
            git config user.name "Jenkins CI"
            git config user.email "jenkins@local"

            # Merge target branch into feature branch
            git merge origin/${targetEnv} --no-commit --no-edit || true

            # Handle env.cue conflicts
            if git diff --name-only --diff-filter=U | grep -q "^env.cue\$"; then
                if [ "${isPromoteBranch}" = "true" ]; then
                    # Promote branches: keep OURS (has promoted image tags)
                    echo "Resolving env.cue conflict (keeping promote branch version with promoted images)"
                    git checkout --ours env.cue
                else
                    # Feature branches: take THEIRS (need target's env config)
                    echo "Resolving env.cue conflict (taking version from ${targetEnv})"
                    git show origin/${targetEnv}:env.cue > env.cue
                fi
                git add env.cue
            fi

            # Handle manifest conflicts - always keep OURS
            # Manifests are derivative (generated from CUE). For non-promote branches,
            # they'll be regenerated. For promote branches, they're already correct.
            MANIFEST_CONFLICTS=\$(git diff --name-only --diff-filter=U 2>/dev/null | grep "^manifests/" || true)
            if [ -n "\$MANIFEST_CONFLICTS" ]; then
                echo "Resolving manifests/ conflicts (keeping current version - derivative files)"
                for file in \$MANIFEST_CONFLICTS; do
                    git checkout --ours "\$file" 2>/dev/null || true
                    git add "\$file" 2>/dev/null || true
                done
            fi

            # Resolve .mr-trigger conflicts (keep ours)
            if git diff --name-only --diff-filter=U | grep -q "^.mr-trigger\$"; then
                echo "Resolving .mr-trigger conflict (keeping current version)"
                git checkout --ours .mr-trigger
                git add .mr-trigger
            fi

            # Resolve services/ conflicts by keeping feature branch version (ours)
            SERVICE_CONFLICTS=\$(git diff --name-only --diff-filter=U 2>/dev/null | grep "^services/" || true)
            if [ -n "\$SERVICE_CONFLICTS" ]; then
                echo "Resolving services/ conflicts (keeping feature branch version):"
                echo "\$SERVICE_CONFLICTS"
                for file in \$SERVICE_CONFLICTS; do
                    git checkout --ours "\$file"
                    git add "\$file"
                done
            fi

            # Check for any remaining unresolved conflicts
            CONFLICTS=\$(git diff --name-only --diff-filter=U 2>/dev/null || true)
            if [ -n "\$CONFLICTS" ]; then
                echo "ERROR: Unresolved merge conflicts:"
                echo "\$CONFLICTS"
                exit 1
            fi

            # Commit the merge if there were changes
            if ! git diff --staged --quiet; then
                git commit --no-edit -m "Merge ${targetEnv} into feature branch for MR-preview"
            fi

            echo "Successfully merged ${targetEnv} into feature branch"

            # Verify env.cue exists
            if [ ! -f "env.cue" ]; then
                echo "ERROR: env.cue not found after merge"
                exit 1
            fi
        """
        return true
    } catch (Exception e) {
        echo "Warning: Could not merge ${targetEnv}: ${e.message}"
        return false
    }
}

/**
 * Validates manifest YAML files using static checks and server-side dry-run
 * @param targetEnv The target environment (dev, stage, or prod)
 * @return true if validation passes, false otherwise
 */
def validateManifests(String targetEnv) {
    container('pipeline') {
        script {
            echo "=== Validating Manifests for ${targetEnv} ==="

            // Static validation (YAML syntax, required fields, security checks)
            sh """
                echo "Running static manifest validation..."
                ./scripts/validate-manifests.sh ${targetEnv} || {
                    echo "ERROR: Static manifest validation failed"
                    exit 1
                }
                echo "Static validation passed"
            """

            // Server-side dry-run validation against the cluster
            // Note: Manifests are organized by app name (manifests/exampleApp/, manifests/postgres/),
            // not by environment. The environment is baked into the manifest content via CUE.
            sh """
                echo "Running server-side dry-run validation..."

                # Find all manifest files (organized by app name, not environment)
                MANIFEST_DIR="manifests"
                if [ ! -d "\$MANIFEST_DIR" ]; then
                    echo "ERROR: Manifest directory not found: \$MANIFEST_DIR"
                    exit 1
                fi

                # Validate each manifest with kubectl dry-run
                FAILED=0
                for manifest in \$(find "\$MANIFEST_DIR" -name "*.yaml" -o -name "*.yml"); do
                    echo "  Validating: \$manifest"
                    if ! kubectl apply --dry-run=server -f "\$manifest" 2>&1; then
                        echo "  ERROR: Dry-run failed for \$manifest"
                        FAILED=1
                    fi
                done

                if [ \$FAILED -ne 0 ]; then
                    echo "ERROR: Server-side dry-run validation failed"
                    exit 1
                fi

                echo "Server-side dry-run validation passed"
            """
        }
    }
}

/**
 * Waits for ArgoCD application to sync and become healthy
 * @param appName ArgoCD application name
 * @param timeoutSeconds Maximum time to wait (default: 300)
 */
def waitForArgoCDSync(String appName, int timeoutSeconds = 300) {
    container('pipeline') {
        script {
            echo "Waiting for ${appName} to sync and become healthy..."

            sh """
                argocd app wait ${appName} \
                    --timeout ${timeoutSeconds} \
                    --health \
                    --sync || {
                    echo "ERROR: ${appName} failed to sync or become healthy"
                    argocd app get ${appName}
                    exit 1
                }

                echo "${appName} synced and healthy"
            """
        }
    }
}

/**
 * Creates a promotion MR to the next environment
 * Performs semantic merge: promotes app config, preserves env-specific fields
 * @param sourceEnv Source environment (dev or stage)
 */
def createPromotionMR(String sourceEnv) {
    container('pipeline') {
        script {
            // Determine target environment
            def targetEnv = ''
            if (sourceEnv == 'dev') {
                targetEnv = 'stage'
            } else if (sourceEnv == 'stage') {
                targetEnv = 'prod'
            } else {
                echo "No promotion needed from ${sourceEnv}"
                return
            }

            echo "=== Creating Promotion MR: ${sourceEnv} -> ${targetEnv} ==="

            withCredentials([
                usernamePassword(credentialsId: 'gitlab-credentials',
                                usernameVariable: 'GIT_USERNAME',
                                passwordVariable: 'GIT_PASSWORD'),
                string(credentialsId: 'gitlab-api-token-secret', variable: 'GITLAB_TOKEN'),
                usernamePassword(credentialsId: 'nexus-credentials',
                                usernameVariable: 'NEXUS_USER',
                                passwordVariable: 'NEXUS_PASSWORD')
            ]) {
                // Check if there's already an open promotion MR to the target
                def projectPath = env.GITLAB_GROUP ? "${env.GITLAB_GROUP}/k8s-deployments" : "p2c/k8s-deployments"
                def encodedProject = projectPath.replace('/', '%2F')
                def existingMR = sh(
                    script: """
                        curl -sf -H "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
                            "${env.GITLAB_URL}/api/v4/projects/${encodedProject}/merge_requests?state=opened&target_branch=${targetEnv}" \
                            2>/dev/null | jq -r '[.[] | select(.source_branch | startswith("promote-${targetEnv}-"))] | first | .iid // empty'
                    """,
                    returnStdout: true
                ).trim()

                if (existingMR) {
                    echo "Promotion MR !${existingMR} already exists for ${targetEnv} - skipping creation"
                    return
                }

                // Get git hash from source environment's current image
                def sourceImageTag = sh(
                    script: """
                        curl -sf -H "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
                            "${env.GITLAB_URL}/api/v4/projects/${encodedProject}/repository/files/env.cue?ref=${sourceEnv}" \
                            2>/dev/null | jq -r '.content' | base64 -d | grep 'image:' | sed -E 's/.*image:\\s*"([^"]+)".*/\\1/' | head -1
                    """,
                    returnStdout: true
                ).trim()

                // Extract just the tag portion (after the colon)
                def imageTag = sourceImageTag.contains(':') ? sourceImageTag.split(':').last() : sourceImageTag

                def gitHash = sh(
                    script: "echo '${imageTag}' | grep -oE '[a-f0-9]{6,}\$' || echo ''",
                    returnStdout: true
                ).trim()

                if (!gitHash) {
                    echo "WARNING: Could not extract git hash from source image tag: ${sourceImageTag}"
                    echo "Skipping artifact promotion - MR will use existing image version"
                }

                echo "Source image tag: ${imageTag}"
                echo "Git hash: ${gitHash}"

                // Promote artifacts (Maven + Docker) and get new image tag
                // Note: Use 'bash' explicitly since GitLab API doesn't preserve execute permissions
                // Note: Explicitly export NEXUS_USER/NEXUS_PASSWORD to ensure they're available to the script
                def newImageTag = ''
                if (gitHash) {
                    newImageTag = sh(
                        script: """
                            export NEXUS_USER="\${NEXUS_USER}"
                            export NEXUS_PASSWORD="\${NEXUS_PASSWORD}"
                            bash ./scripts/promote-artifact.sh \
                                --source-env ${sourceEnv} \
                                --target-env ${targetEnv} \
                                --app-name example-app \
                                --git-hash ${gitHash} \
                                2>&1 | tee /tmp/promote.log | tail -1
                        """,
                        returnStdout: true
                    ).trim()

                    if (!newImageTag || newImageTag.contains("ERROR") || newImageTag.contains("[")) {
                        echo "Artifact promotion output:"
                        sh "cat /tmp/promote.log || true"
                        error "Artifact promotion failed - cannot create promotion MR without valid image tag. If release version already exists in Nexus, bump the version in pom.xml."
                    }
                    echo "New image tag for ${targetEnv}: ${newImageTag}"
                }

                sh '''
                    git config --global user.name "Jenkins CI"
                    git config --global user.email "jenkins@local"
                    git config --global credential.helper '!f() { printf "username=%s\\npassword=%s\\n" "${GIT_USERNAME}" "${GIT_PASSWORD}"; }; f'
                '''

                sh """
                    # Fetch both branches
                    git fetch origin ${sourceEnv} ${targetEnv}

                    # Create promotion branch from target
                    TIMESTAMP=\$(date +%Y%m%d-%H%M%S)
                    PROMOTION_BRANCH="promote-${targetEnv}-\${TIMESTAMP}"

                    git checkout -B ${targetEnv} origin/${targetEnv}
                    git checkout -b "\${PROMOTION_BRANCH}"

                    # Promote app config from source to target
                    ./scripts/promote-app-config.sh ${sourceEnv} ${targetEnv} || {
                        echo "ERROR: App config promotion failed"
                        exit 1
                    }

                    # Update image tag in env.cue with promoted version (if we have one)
                    NEW_IMAGE_TAG="${newImageTag}"
                    if [ -n "\${NEW_IMAGE_TAG}" ]; then
                        # Use external registry URL (HTTPS) - internal URL isn't resolvable from kubelet
                        REGISTRY="\${DOCKER_REGISTRY_EXTERNAL:-docker.jmann.local}"
                        NEW_IMAGE="\${REGISTRY}/p2c/example-app:\${NEW_IMAGE_TAG}"

                        echo "Updating env.cue with new image: \${NEW_IMAGE}"

                        # Use sed to update the image field
                        # Note: \\\" escapes through both Groovy and shell to produce literal "
                        sed -i "s|image:.*example-app:[^\\\"]*\\\"|image: \\\"\${NEW_IMAGE}\\\"|" env.cue

                        # Verify the update
                        echo "Updated image in env.cue:"
                        grep "image:" env.cue
                    fi

                    # Regenerate manifests with promoted config
                    ./scripts/generate-manifests.sh ${targetEnv} || {
                        echo "ERROR: Manifest generation failed"
                        exit 1
                    }

                    # Check if there are any changes to commit
                    if git diff --quiet && git diff --cached --quiet; then
                        echo "No changes to promote - config already in sync"
                        exit 0
                    fi

                    # Commit changes
                    git add -A
                    git commit -m "Promote ${sourceEnv} to ${targetEnv}

Automated promotion after successful ${sourceEnv} deployment.

Source: ${sourceEnv}
Target: ${targetEnv}
Build: ${env.BUILD_URL}"

                    # Push promotion branch
                    git push -u origin "\${PROMOTION_BRANCH}"

                    # Create MR using GitLab API
                    export GITLAB_URL_INTERNAL="${env.GITLAB_URL}"

                    ./scripts/create-gitlab-mr.sh \\
                        "\${PROMOTION_BRANCH}" \\
                        "${targetEnv}" \\
                        "Promote ${sourceEnv} to ${targetEnv}" \\
                        "Automated promotion MR after successful ${sourceEnv} deployment.

## What's Promoted
- Container images (CI/CD managed)
- Application environment variables
- ConfigMap data

## What's Preserved
- Namespace: ${targetEnv}
- Replicas, resources, debug flags

---
**Source:** ${sourceEnv}
**Target:** ${targetEnv}
**Jenkins Build:** ${env.BUILD_URL}"

                    echo "Created promotion MR: \${PROMOTION_BRANCH} -> ${targetEnv}"
                """

                sh 'git config --global --unset credential.helper || true'
            }
        }
    }
}

// ============================================================================
// MAIN PIPELINE
// ============================================================================

def agentImage = System.getenv('JENKINS_AGENT_IMAGE')
if (!agentImage) {
    error "JENKINS_AGENT_IMAGE environment variable is required but not set."
}

// Docker registry host for dind insecure-registry config (strip https:// prefix)
def dockerRegistryHost = System.getenv('DOCKER_REGISTRY_EXTERNAL')?.replaceAll('^https?://', '')

pipeline {
    agent {
        kubernetes {
            yaml """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: pipeline
    image: ${agentImage}
    command:
    - cat
    tty: true
    env:
    - name: DOCKER_HOST
      value: tcp://localhost:2375
    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "1Gi"
        cpu: "1000m"
  - name: dind
    image: docker:dind
    securityContext:
      privileged: true
    env:
    - name: DOCKER_TLS_CERTDIR
      value: ""
    args:
    - --insecure-registry=${dockerRegistryHost}
    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "2Gi"
        cpu: "1000m"
"""
        }
    }

    options {
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '30', daysToKeepStr: '60'))
        disableConcurrentBuilds()
    }

    environment {
        GITLAB_URL = System.getenv('GITLAB_URL_INTERNAL')
        GITLAB_GROUP = System.getenv('GITLAB_GROUP')
        DEPLOYMENTS_REPO = System.getenv('DEPLOYMENTS_REPO_URL')
        // External Docker registry (HTTPS) for Docker daemon operations
        DOCKER_REGISTRY_EXTERNAL = System.getenv('DOCKER_REGISTRY_EXTERNAL')
        ARGOCD_SERVER = 'argocd-server.argocd.svc.cluster.local:80'
        ARGOCD_OPTS = '--plaintext --grpc-web'
        ENV_BRANCHES = 'dev,stage,prod'
        PROMOTE_BRANCHES = 'dev,stage'
    }

    stages {
        stage('Initialize') {
            steps {
                container('pipeline') {
                    script {
                        echo """
=======================================================
k8s-deployments CI/CD Pipeline
=======================================================
Branch: ${env.BRANCH_NAME}
Build: ${env.BUILD_URL}
=======================================================
"""
                        env.ORIGINAL_COMMIT_SHA = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
                        echo "Commit SHA: ${env.ORIGINAL_COMMIT_SHA}"

                        // Check for [no-promote] flag in the current merge only
                        // For merge commits: check commits from the merged branch (HEAD^1..HEAD^2)
                        // For direct pushes: check just HEAD
                        // This ensures historical [no-promote] commits don't affect new merges
                        def commitMessages = ''
                        def isMergeCommit = sh(script: 'git rev-parse HEAD^2 >/dev/null 2>&1 && echo "true" || echo "false"', returnStdout: true).trim()
                        if (isMergeCommit == 'true') {
                            // Get commits from the merged branch only
                            commitMessages = sh(script: 'git log HEAD^1..HEAD^2 --pretty=%B', returnStdout: true).trim()
                            // Also check the merge commit message itself
                            def mergeMsg = sh(script: 'git log -1 --pretty=%B', returnStdout: true).trim()
                            commitMessages = mergeMsg + "\n" + commitMessages
                            echo "Merge commit detected - checking merged branch commits for [no-promote]"
                        } else {
                            commitMessages = sh(script: 'git log -1 --pretty=%B', returnStdout: true).trim()
                            echo "Direct push detected - checking HEAD commit for [no-promote]"
                        }
                        env.NO_PROMOTE = commitMessages.contains('[no-promote]') ? 'true' : 'false'
                        if (env.NO_PROMOTE == 'true') {
                            echo "INFO: [no-promote] flag detected - skipping promotion MR creation"
                        }

                        if (!env.GITLAB_URL) {
                            error "GITLAB_URL_INTERNAL not set. Configure pipeline-config ConfigMap."
                        }

                        // Determine branch type and MR status
                        env.IS_ENV_BRANCH = (env.BRANCH_NAME in ['dev', 'stage', 'prod']) ? 'true' : 'false'
                        env.HAS_OPEN_MR = 'false'
                        env.MR_TARGET_ENV = ''

                        withCredentials([string(credentialsId: 'gitlab-api-token-secret', variable: 'GITLAB_TOKEN')]) {
                            def projectPath = env.GITLAB_GROUP ? "${env.GITLAB_GROUP}/k8s-deployments" : "p2c/k8s-deployments"
                            def mrTarget = getMRTargetEnvironment(env.BRANCH_NAME, GITLAB_TOKEN, env.GITLAB_URL, projectPath)
                            if (mrTarget) {
                                env.HAS_OPEN_MR = 'true'
                                env.MR_TARGET_ENV = mrTarget
                            }
                        }

                        // Determine target environment
                        def targetEnv = getTargetEnvironment(env.BRANCH_NAME)
                        if (env.HAS_OPEN_MR == 'true' && env.IS_ENV_BRANCH == 'false') {
                            targetEnv = env.MR_TARGET_ENV
                        }
                        env.TARGET_ENV = targetEnv ?: ''

                        echo """
Branch Type: ${env.IS_ENV_BRANCH == 'true' ? 'Environment' : 'Feature'}
Has Open MR: ${env.HAS_OPEN_MR}
Target Environment: ${env.TARGET_ENV ?: 'N/A'}
"""
                    }
                }
            }
        }

        stage('Prepare Merge Preview') {
            when {
                expression {
                    // Only for feature branches with open MRs (need to merge target for env.cue)
                    env.TARGET_ENV != '' && env.HAS_OPEN_MR == 'true' && env.IS_ENV_BRANCH == 'false'
                }
            }
            steps {
                container('pipeline') {
                    script {
                        echo "=== Preparing MR Preview: Merging ${env.MR_TARGET_ENV} ==="

                        def isPromoteBranch = env.BRANCH_NAME.startsWith('promote-')
                        if (isPromoteBranch) {
                            echo "Promote branch detected - will preserve promoted image versions"
                        }

                        withCredentials([
                            usernamePassword(credentialsId: 'gitlab-credentials',
                                            usernameVariable: 'GIT_USERNAME',
                                            passwordVariable: 'GIT_PASSWORD')
                        ]) {
                            sh 'git config --global credential.helper \'!f() { printf "username=%s\\npassword=%s\\n" "${GIT_USERNAME}" "${GIT_PASSWORD}"; }; f\''
                            if (!mergeTargetBranchForPreview(env.MR_TARGET_ENV, isPromoteBranch)) {
                                error "Could not merge ${env.MR_TARGET_ENV} - cannot proceed"
                            }
                            sh 'git config --global --unset credential.helper || true'
                        }
                    }
                }
            }
        }

        stage('Validate CUE') {
            when {
                expression { env.TARGET_ENV != '' }
            }
            steps {
                container('pipeline') {
                    script {
                        // Pure validation - no side effects
                        echo "Validating CUE configuration..."
                        sh '''
                            if [ -x "./scripts/validate-cue-config.sh" ]; then
                                ./scripts/validate-cue-config.sh || {
                                    echo "CUE validation failed"
                                    exit 1
                                }
                            else
                                cue vet ./env.cue || {
                                    echo "CUE validation failed"
                                    exit 1
                                }
                            fi
                            echo "CUE configuration is valid"
                        '''
                    }
                }
            }
        }

        stage('Generate Manifests') {
            when {
                expression {
                    // Only generate manifests for feature branches with open MRs
                    // Environment branches receive manifests via merge - no regeneration
                    // Exclude promote-* branches - they carry already-generated manifests from source env
                    // (regenerating would cause feedback loop: build -> push -> webhook -> build)
                    env.TARGET_ENV != '' && env.HAS_OPEN_MR == 'true' && env.IS_ENV_BRANCH == 'false' &&
                    !env.BRANCH_NAME.startsWith('promote-')
                }
            }
            steps {
                container('pipeline') {
                    script {
                        echo "Generating manifests for ${env.TARGET_ENV}..."
                        sh """
                            ./scripts/generate-manifests.sh ${env.TARGET_ENV} || {
                                echo "Manifest generation failed"
                                exit 1
                            }
                        """

                        // Commit and push manifests back to feature branch
                        withCredentials([
                            usernamePassword(credentialsId: 'gitlab-credentials',
                                            usernameVariable: 'GIT_USERNAME',
                                            passwordVariable: 'GIT_PASSWORD')
                        ]) {
                            sh '''
                                git config --global user.name "Jenkins CI"
                                git config --global user.email "jenkins@local"
                                git config --global credential.helper '!f() { printf "username=%s\\npassword=%s\\n" "${GIT_USERNAME}" "${GIT_PASSWORD}"; }; f'
                            '''

                            sh """
                                git add manifests/ 2>/dev/null || true

                                if git diff --cached --quiet manifests/ 2>/dev/null && \
                                   [ -z "\$(git status --porcelain manifests/ 2>/dev/null)" ]; then
                                    echo "No manifest changes to commit"
                                else
                                    echo "Committing generated manifests..."
                                    git add manifests/
                                    git commit -m "chore: regenerate manifests [jenkins-ci]

Generated by Jenkins CI.
Build: ${env.BUILD_URL}"
                                    git push origin HEAD:\${GIT_BRANCH#origin/}
                                    echo "Manifests committed and pushed"
                                fi

                                git config --global --unset credential.helper || true
                            """
                        }

                        // Capture final commit SHA
                        env.FINAL_COMMIT_SHA = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
                    }
                }
            }
        }

        stage('Validate Manifests') {
            when {
                expression { env.TARGET_ENV != '' }
            }
            steps {
                script {
                    validateManifests(env.TARGET_ENV)
                }
            }
        }

        stage('Deploy to Environment') {
            when {
                expression {
                    // Only deploy for environment branches (post-merge)
                    env.IS_ENV_BRANCH == 'true' && env.TARGET_ENV != ''
                }
            }
            stages {
                stage('Login to ArgoCD') {
                    steps {
                        container('pipeline') {
                            script {
                                echo "=== Logging into ArgoCD ==="
                                withCredentials([
                                    usernamePassword(credentialsId: 'argocd-credentials',
                                                    usernameVariable: 'ARGOCD_USERNAME',
                                                    passwordVariable: 'ARGOCD_PASSWORD')
                                ]) {
                                    sh """
                                        argocd login ${env.ARGOCD_SERVER} \
                                            --username \${ARGOCD_USERNAME} \
                                            --password \${ARGOCD_PASSWORD} \
                                            ${env.ARGOCD_OPTS}
                                    """
                                }
                            }
                        }
                    }
                }

                stage('Refresh & Sync') {
                    steps {
                        container('pipeline') {
                            script {
                                def appName = "example-app-${env.BRANCH_NAME}"
                                echo "=== Refreshing ArgoCD Application: ${appName} ==="

                                sh """
                                    argocd app get ${appName} --refresh || {
                                        echo "WARNING: Failed to refresh ${appName}"
                                        exit 1
                                    }
                                """
                            }
                        }
                    }
                }

                stage('Wait for Health') {
                    steps {
                        script {
                            def appName = "example-app-${env.BRANCH_NAME}"
                            waitForArgoCDSync(appName, 300)
                        }
                    }
                }

                stage('Deployment Summary') {
                    steps {
                        container('pipeline') {
                            echo """
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
DEPLOYMENT SUCCESSFUL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Environment: ${env.BRANCH_NAME}
Build: ${env.BUILD_URL}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""
                        }
                    }
                }
            }
        }

        stage('Create Promotion MR') {
            when {
                expression {
                    // Only create promotion MR for dev/stage after successful deployment
                    // Skip if commit message contains [no-promote]
                    env.BRANCH_NAME in env.PROMOTE_BRANCHES.split(',') &&
                    env.IS_ENV_BRANCH == 'true' &&
                    env.NO_PROMOTE != 'true'
                }
            }
            steps {
                script {
                    createPromotionMR(env.BRANCH_NAME)
                }
            }
        }
    }

    post {
        success {
            script {
                echo """
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PIPELINE COMPLETED SUCCESSFULLY
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Branch: ${env.BRANCH_NAME}
Build: ${env.BUILD_URL}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""
                container('pipeline') {
                    withCredentials([string(credentialsId: 'gitlab-api-token-secret', variable: 'GITLAB_TOKEN')]) {
                        sh """
                            COMMIT_SHA="${env.FINAL_COMMIT_SHA ?: env.ORIGINAL_COMMIT_SHA}"
                            echo "Reporting success status for commit: \$COMMIT_SHA"
                            curl -s -X POST \
                                -H "PRIVATE-TOKEN: \${GITLAB_TOKEN}" \
                                -H "Content-Type: application/json" \
                                -d '{"state": "success", "description": "Pipeline passed", "context": "jenkins/k8s-deployments"}' \
                                "${env.GITLAB_URL}/api/v4/projects/${env.GITLAB_GROUP ?: 'p2c'}%2Fk8s-deployments/statuses/\$COMMIT_SHA" \
                                || echo "Could not update commit status"
                        """
                    }
                }
            }
        }

        failure {
            script {
                echo """
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PIPELINE FAILED
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Branch: ${env.BRANCH_NAME}
Check logs above for error details.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""
                container('pipeline') {
                    withCredentials([string(credentialsId: 'gitlab-api-token-secret', variable: 'GITLAB_TOKEN')]) {
                        sh """
                            COMMIT_SHA="${env.FINAL_COMMIT_SHA ?: env.ORIGINAL_COMMIT_SHA}"
                            echo "Reporting failure status for commit: \$COMMIT_SHA"
                            curl -s -X POST \
                                -H "PRIVATE-TOKEN: \${GITLAB_TOKEN}" \
                                -H "Content-Type: application/json" \
                                -d '{"state": "failed", "description": "Pipeline failed", "context": "jenkins/k8s-deployments"}' \
                                "${env.GITLAB_URL}/api/v4/projects/${env.GITLAB_GROUP ?: 'p2c'}%2Fk8s-deployments/statuses/\$COMMIT_SHA" \
                                || echo "Could not update commit status"
                        """
                    }
                }
            }
        }

        always {
            sh 'echo "Pipeline cleanup completed"'
        }
    }
}
