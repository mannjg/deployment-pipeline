#!/usr/bin/env bash
#
# Reset Demo State
#
# Establishes a well-defined starting point for demos by resetting CUE
# configuration to canonical baselines while preserving CI/CD-managed images.
#
# Usage:
#   ./scripts/03-pipelines/reset-demo-state.sh
#
# Clean Starting Point:
#   - Jenkins queue cleared (no stale running/queued jobs)
#   - No stale local demo branches (uc-*, update-dev-*, promote-*)
#   - No orphaned GitLab demo branches
#   - No open MRs targeting dev, stage, or prod branches
#   - services/ directory reset to main branch (all CUE definitions)
#   - env.cue reset to baseline (preserving CI/CD-managed images)
#   - Manifests regenerated by Jenkins from clean CUE
#
# What it preserves:
#   - CI/CD-managed image tags in env.cue
#   - Environment branches (dev, stage, prod, main)
#   - App version in pom.xml (demo-uc-e1-app-deployment.sh manages version bumps)
#
# Baseline files: scripts/03-pipelines/baselines/env-{dev,stage,prod}.cue
#

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() { echo -e "${GREEN}[INFO]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*"; }
log_step() { echo -e "\n${BLUE}[->]${NC} $*"; }

# Script paths
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
BASELINES_DIR="$SCRIPT_DIR/baselines"

# Parse command-line arguments
BRANCHES="dev,stage,prod"  # Default: all branches
RESET_EXAMPLE_APP=false    # Default: don't reset example-app

while [[ $# -gt 0 ]]; do
    case $1 in
        --branches)
            BRANCHES="$2"
            shift 2
            ;;
        --reset-example-app)
            RESET_EXAMPLE_APP=true
            shift
            ;;
        --help|-h)
            echo "Usage: $0 [--branches dev,stage,prod] [--reset-example-app]"
            echo ""
            echo "Options:"
            echo "  --branches          Comma-separated list of branches to reset (default: dev,stage,prod)"
            echo "  --reset-example-app Also reset example-app repo (cleans UC-E2 artifacts)"
            echo ""
            echo "Environment:"
            echo "  CLUSTER_CONFIG      Path to cluster config file (required)"
            echo ""
            echo "Examples:"
            echo "  CLUSTER_CONFIG=config/clusters/reference.env $0"
            echo "  $0 --branches dev         # Reset dev only"
            echo "  $0 --branches dev,stage   # Reset dev and stage"
            echo "  $0 --reset-example-app    # Reset all + clean example-app demo artifacts"
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Convert comma-separated branches to array
IFS=',' read -ra BRANCH_LIST <<< "$BRANCHES"
log_info "Target branches: ${BRANCH_LIST[*]}"
if [[ "$RESET_EXAMPLE_APP" == "true" ]]; then
    log_info "Example-app cleanup: enabled"
fi

# Load infrastructure config (requires CLUSTER_CONFIG env var)
source "$REPO_ROOT/scripts/lib/infra.sh" "${CLUSTER_CONFIG:-}"

# Set MR workflow configuration (required before sourcing library)
export MR_WORKFLOW_TIMEOUT=600
export MR_WORKFLOW_POLL_INTERVAL=15

# Load MR workflow library
source "$SCRIPT_DIR/../lib/mr-workflow.sh"

# Credentials are loaded by mr-workflow.sh via require_* functions
# GITLAB_TOKEN, JENKINS_USER, JENKINS_TOKEN are now set
# GITLAB_URL_EXTERNAL, JENKINS_URL_EXTERNAL are set by infra.sh

# =============================================================================
# Phase 0: Wait for pipeline quiescence before any cleanup
# =============================================================================
# This prevents a race condition where auto-promote webhooks from the previous
# demo trigger builds while we're deleting agent pods. We must wait for all
# in-flight builds to complete before starting cleanup.
wait_for_pipeline_quiescence() {
    local timeout="${1:-120}"
    local jenkins_cli="$SCRIPT_DIR/../04-operations/jenkins-cli.sh"
    local start_time=$(date +%s)

    log_step "Phase 0: Waiting for pipeline quiescence before cleanup..."
    log_info "Ensuring no builds are in-flight from previous operations..."

    while true; do
        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))

        if [[ $elapsed -ge $timeout ]]; then
            log_warn "Pipeline quiescence timeout after ${timeout}s - proceeding with cleanup"
            return 0  # Don't fail, just warn and proceed
        fi

        local status_parts=()

        # 1. Check Jenkins API for running builds on env branches
        #    Catches builds that Jenkins knows about even if pods aren't scheduled yet
        for env in "${BRANCH_LIST[@]}"; do
            local status_json=$("$jenkins_cli" status "k8s-deployments/$env" 2>/dev/null || echo '{}')
            local building=$(echo "$status_json" | jq -r '.building // false')
            if [[ "$building" == "true" ]]; then
                status_parts+=("$env:running")
            fi
        done

        # 2. Check Jenkins build queue (catches builds between webhook and pod creation)
        local queue_json=$(curl -sk -u "$JENKINS_USER:$JENKINS_TOKEN" \
            "$JENKINS_URL_EXTERNAL/queue/api/json" 2>/dev/null || echo '{"items":[]}')
        local queue_count=$(echo "$queue_json" | jq -r '.items | length' 2>/dev/null || echo 0)
        if [[ "$queue_count" -gt 0 ]]; then
            status_parts+=("queue:${queue_count}")
        fi

        # 3. Check for ANY Jenkins agent pods (catches feature branch, example-app,
        #    and any other builds that the env branch check above would miss)
        local agent_count=$(kubectl get pods -n "${JENKINS_NAMESPACE}" --no-headers \
            -o custom-columns=NAME:.metadata.name 2>/dev/null | grep -cv "^jenkins-" 2>/dev/null || echo 0)
        if [[ "$agent_count" -gt 0 ]]; then
            status_parts+=("pods:${agent_count}")
        fi

        if [[ ${#status_parts[@]} -eq 0 ]]; then
            log_info "  ✓ Pipeline is quiescent - safe to proceed with cleanup"
            return 0
        fi

        log_info "  Waiting for: ${status_parts[*]} (${elapsed}s elapsed)"
        sleep 10
    done
}

# =============================================================================
# Phase 1: Clean up Jenkins queue and running jobs
# =============================================================================
cleanup_jenkins_queue() {
    log_step "Phase 1: Cleaning up Jenkins queue and running jobs..."

    if [[ -z "$JENKINS_USER" ]] || [[ -z "$JENKINS_TOKEN" ]]; then
        log_warn "Jenkins credentials not available, skipping queue cleanup"
        return 0
    fi

    local jenkins_auth="$JENKINS_USER:$JENKINS_TOKEN"

    # Fetch Jenkins CRUMB for CSRF protection
    local crumb_response=$(curl -sk -u "$jenkins_auth" "$JENKINS_URL_EXTERNAL/crumbIssuer/api/json" 2>/dev/null)
    local crumb_field=$(echo "$crumb_response" | jq -r '.crumbRequestField // empty' 2>/dev/null)
    local crumb_value=$(echo "$crumb_response" | jq -r '.crumb // empty' 2>/dev/null)

    if [[ -z "$crumb_field" ]] || [[ -z "$crumb_value" ]]; then
        log_warn "Could not fetch Jenkins CRUMB, POST operations may fail"
        local crumb_header=""
    else
        local crumb_header="-H $crumb_field:$crumb_value"
    fi

    # 1. Cancel all queued items
    log_info "Canceling queued Jenkins jobs..."
    local queue_items=$(curl -sk -u "$jenkins_auth" "$JENKINS_URL_EXTERNAL/queue/api/json" 2>/dev/null | \
        jq -r '.items[].id' 2>/dev/null || true)

    local canceled=0
    if [[ -n "$queue_items" ]]; then
        for item_id in $queue_items; do
            curl -sk -X POST -u "$jenkins_auth" $crumb_header \
                "$JENKINS_URL_EXTERNAL/queue/cancelItem?id=$item_id" >/dev/null 2>&1 && \
                canceled=$((canceled + 1))
        done
    fi
    log_info "  Canceled $canceled queued items"

    # 2. Abort running builds for k8s-deployments branches
    log_info "Aborting running Jenkins builds..."
    local aborted=0

    local jobs=$(curl -sk -u "$jenkins_auth" "$JENKINS_URL_EXTERNAL/job/k8s-deployments/api/json" 2>/dev/null | \
        jq -r '.jobs[].name' 2>/dev/null || true)

    if [[ -n "$jobs" ]]; then
        for job_name in $jobs; do
            local encoded_job=$(echo "$job_name" | jq -sRr @uri)
            local builds=$(curl -sk -u "$jenkins_auth" \
                "$JENKINS_URL_EXTERNAL/job/k8s-deployments/job/$encoded_job/api/json" 2>/dev/null | \
                jq -r '.builds[]? | select(.building == true) | .number' 2>/dev/null || true)

            for build_num in $builds; do
                if [[ -n "$build_num" ]]; then
                    curl -sk -X POST -u "$jenkins_auth" $crumb_header \
                        "$JENKINS_URL_EXTERNAL/job/k8s-deployments/job/$encoded_job/$build_num/stop" >/dev/null 2>&1 && \
                        aborted=$((aborted + 1))
                fi
            done
        done
    fi
    log_info "  Aborted $aborted running builds"

    # 3. Delete all Jenkins agent pods
    log_info "Deleting Jenkins agent pods..."
    local deleted_pods=$(kubectl get pods -n "${JENKINS_NAMESPACE}" --no-headers -o custom-columns=NAME:.metadata.name 2>/dev/null | \
        grep -v "^jenkins-" | wc -l)

    kubectl get pods -n "${JENKINS_NAMESPACE}" --no-headers -o custom-columns=NAME:.metadata.name 2>/dev/null | \
        grep -v "^jenkins-" | \
        xargs -r kubectl delete pod -n "${JENKINS_NAMESPACE}" --force --grace-period=0 >/dev/null 2>&1 || true

    log_info "  Deleted $deleted_pods agent pods"

    # 4. Wait for Jenkins to stabilize
    log_info "Waiting for Jenkins to stabilize..."
    sleep 5
}

# =============================================================================
# Phase 2: Clean up branches and MRs
# =============================================================================
cleanup_local_branches() {
    log_info "Cleaning up local demo branches..."

    local patterns=("uc-*" "update-dev-*" "promote-*" "sync-main-*" "reset-demo-*")
    local deleted=0

    for pattern in "${patterns[@]}"; do
        local branches=$(git branch --list "$pattern" 2>/dev/null | sed 's/^[* ]*//')
        if [[ -n "$branches" ]]; then
            while IFS= read -r branch; do
                if [[ -n "$branch" ]]; then
                    git branch -D "$branch" >/dev/null 2>&1 && deleted=$((deleted + 1))
                fi
            done <<< "$branches"
        fi
    done

    if [[ $deleted -gt 0 ]]; then
        log_info "  Deleted $deleted local demo branches"
    else
        log_info "  No local demo branches to clean"
    fi
}

cleanup_gitlab_orphan_branches() {
    local project_path="$1"
    local gitlab_cli="$SCRIPT_DIR/../04-operations/gitlab-cli.sh"

    log_info "Cleaning up orphaned GitLab demo branches..."

    local patterns=("uc-" "update-dev-" "promote-" "sync-main-" "reset-demo-")
    local deleted=0

    for pattern in "${patterns[@]}"; do
        local branches
        if branches=$("$gitlab_cli" branch list "$project_path" --pattern "${pattern}*" 2>/dev/null); then
            while IFS= read -r branch; do
                if [[ -n "$branch" ]]; then
                    if "$gitlab_cli" branch delete "$project_path" "$branch" >/dev/null 2>&1; then
                        deleted=$((deleted + 1))
                    fi
                fi
            done <<< "$branches"
        fi
    done

    if [[ $deleted -gt 0 ]]; then
        log_info "  Deleted $deleted orphaned GitLab demo branches"
    else
        log_info "  No orphaned GitLab demo branches to clean"
    fi
}

close_all_env_mrs() {
    local project_path="$1"
    local gitlab_cli="$SCRIPT_DIR/../04-operations/gitlab-cli.sh"

    log_info "Closing ALL open MRs targeting environment branches..."

    # Always check all env branches for MRs, not just BRANCH_LIST
    # This is critical because merging to dev creates promote MRs to stage/prod
    for target_branch in dev stage prod; do
        local mr_list
        if ! mr_list=$("$gitlab_cli" mr list "$project_path" --state opened --target "$target_branch" 2>/dev/null); then
            log_info "  $target_branch: no open MRs"
            continue
        fi

        local all_mrs=$(echo "$mr_list" | jq -r '"\(.iid):\(.source_branch)"' 2>/dev/null)

        if [[ -z "$all_mrs" ]]; then
            log_info "  $target_branch: no open MRs"
            continue
        fi

        local count=0
        while IFS=: read -r mr_iid source_branch; do
            if [[ -n "$mr_iid" ]]; then
                log_info "  Closing MR !$mr_iid ($source_branch → $target_branch)..."
                "$gitlab_cli" mr close "$project_path" "$mr_iid" >/dev/null 2>&1 || true

                # Delete source branch if it's not an environment branch
                if [[ "$source_branch" != "dev" && "$source_branch" != "stage" && "$source_branch" != "prod" && "$source_branch" != "main" ]]; then
                    "$gitlab_cli" branch delete "$project_path" "$source_branch" >/dev/null 2>&1 || true
                fi

                count=$((count + 1))
            fi
        done <<< "$all_mrs"

        log_info "  $target_branch: closed $count MRs"
    done
}

# =============================================================================
# Wait for example-app builds to complete
# =============================================================================
# After cleaning up example-app, Jenkins builds the main branch and creates
# an MR to k8s-deployments. We must wait for both the build AND the MR creation.
wait_for_example_app_build() {
    local timeout="${1:-300}"
    local jenkins_cli="$SCRIPT_DIR/../04-operations/jenkins-cli.sh"
    local start_time=$(date +%s)

    log_info "Waiting for example-app/main build to complete..."

    # Brief delay to allow webhook to trigger the build
    sleep 5

    while true; do
        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))

        if [[ $elapsed -ge $timeout ]]; then
            log_warn "Timeout waiting for example-app build after ${timeout}s - proceeding"
            return 0
        fi

        # Check if build is running or queued
        local status_json=$("$jenkins_cli" status "example-app/main" 2>/dev/null || echo '{}')
        local building=$(echo "$status_json" | jq -r '.building // false')

        # Check queue for example-app
        local queue_json=$(curl -sk -u "$JENKINS_USER:$JENKINS_TOKEN" \
            "$JENKINS_URL_EXTERNAL/queue/api/json" 2>/dev/null || echo '{"items":[]}')
        local queued=$(echo "$queue_json" | jq -r \
            '[.items[] | select(.task.name == "main" and (.task.url | contains("example-app")))] | length')

        if [[ "$building" == "false" ]] && [[ "$queued" == "0" ]]; then
            log_info "  ✓ example-app build complete"
            # Wait a bit more for MR creation - Jenkins creates MR at very end of build
            log_info "  Waiting for MR creation (post-build)..."
            sleep 10
            return 0
        fi

        local status_msg=""
        [[ "$building" == "true" ]] && status_msg="running"
        [[ "$queued" != "0" ]] && status_msg="${status_msg:+$status_msg+}queued"
        log_info "  example-app: $status_msg (${elapsed}s elapsed)"

        sleep 10
    done
}

# =============================================================================
# Phase 2b: Reset example-app repository (optional)
# =============================================================================
# Cleans up demo artifacts that UC-E2 and similar demos leave behind.
# This is optional because most demos only modify k8s-deployments.

cleanup_example_app() {
    local gitlab_cli="$SCRIPT_DIR/../04-operations/gitlab-cli.sh"
    local app_repo="$APP_REPO_PATH"  # From infra.env: p2c/example-app

    log_step "Phase 2b: Cleaning up example-app demo artifacts..."

    # Get current files from GitLab main branch
    local current_java=$("$gitlab_cli" file get "$app_repo" src/main/java/com/example/app/GreetingService.java --ref main 2>/dev/null)
    local current_cue=$("$gitlab_cli" file get "$app_repo" deployment/app.cue --ref main 2>/dev/null)

    if [[ -z "$current_java" ]] || [[ -z "$current_cue" ]]; then
        log_warn "Could not fetch example-app files, skipping cleanup"
        return 0
    fi

    # Check if cleanup is needed (look for UC-E2 artifacts)
    local needs_cleanup=false
    local files_to_update=()

    if echo "$current_java" | grep -q "UC_E2_FEATURE"; then
        needs_cleanup=true
        # Remove UC-E2 lines from GreetingService.java
        local clean_java=$(echo "$current_java" | grep -v "UC-E2:" | grep -v "UC_E2_FEATURE" | grep -v "ucE2Feature")
        files_to_update+=("src/main/java/com/example/app/GreetingService.java:$clean_java")
        log_info "  Found UC-E2 artifacts in GreetingService.java"
    fi

    if echo "$current_cue" | grep -q "UC_E2_FEATURE"; then
        needs_cleanup=true
        # Remove UC-E2 block from deployment/app.cue using perl for multi-line
        local clean_cue=$(echo "$current_cue" | perl -0777 -pe 's/\s*\{\s*name:\s*"UC_E2_FEATURE"\s*value:\s*"[^"]*"\s*\},?//gs')
        files_to_update+=("deployment/app.cue:$clean_cue")
        log_info "  Found UC-E2 artifacts in deployment/app.cue"
    fi

    if [[ "$needs_cleanup" != "true" ]]; then
        log_info "  No demo artifacts found in example-app - already clean"
        return 0
    fi

    # Use MR workflow to make changes via GitLab API
    # This is the correct approach - all changes to GitLab repos go through MRs
    log_info "  Creating cleanup MR for example-app/main..."

    local timestamp=$(date +%s)
    local branch_name="cleanup-demo-artifacts-${timestamp}"
    local title="chore: cleanup demo artifacts from example-app"
    local commit_message="chore: cleanup demo artifacts from example-app

Removes UC-E2 artifacts (UC_E2_FEATURE references) from source code.

Automated cleanup by reset-demo-state.sh"

    # Build files array for MR workflow
    local files_for_mr=()
    for entry in "${files_to_update[@]}"; do
        local file_path="${entry%%:*}"
        local content="${entry#*:}"
        local content_b64=$(echo "$content" | base64 -w0)
        files_for_mr+=("$file_path:base64:$content_b64")
    done

    # Execute MR workflow (creates branch, commits, MR, waits for CI, merges)
    if mw_complete_mr_workflow \
        "$app_repo" \
        "main" \
        "$branch_name" \
        "$title" \
        "$commit_message" \
        "${files_for_mr[@]}"; then
        log_info "  ✓ Cleanup MR !$MW_RESULT_MR_IID merged to example-app/main"
        return 0
    else
        log_error "  Failed to create/merge cleanup MR for example-app"
        return 1
    fi
}

# =============================================================================
# Phase 3: Reset CUE Configuration (Baseline Approach)
# =============================================================================

# Extract git hash from image tag
# Input: docker.jmann.local/p2c/example-app:1.0.74-SNAPSHOT-7976886
# Output: 7976886
extract_git_hash_from_image() {
    local image="$1"
    # Git hash is the last segment after the final hyphen (6+ hex chars)
    echo "$image" | grep -oE '[a-f0-9]{6,}$' || echo ""
}

# Extract base version from image tag (without SNAPSHOT/rc suffix)
# Input: docker.jmann.local/p2c/example-app:1.0.74-SNAPSHOT-7976886
# Output: 1.0.74
extract_base_version_from_image() {
    local image="$1"
    # Extract tag after colon, then get version number
    local tag="${image##*:}"
    # Remove SNAPSHOT suffix, rc suffix, and git hash
    echo "$tag" | sed -E 's/-(SNAPSHOT|rc[0-9]*)-[a-f0-9]+$//' | sed -E 's/-[a-f0-9]+$//'
}

# Convert prod image tag to match stage's git hash
# This is used when prod has an older version than stage and needs to be aligned
# Input: stage_image (e.g., docker.jmann.local/p2c/example-app:1.0.74-rc1-7976886)
# Output: prod format with same hash (e.g., docker.jmann.local/p2c/example-app:1.0.74-7976886)
convert_stage_image_to_prod_format() {
    local stage_image="$1"
    local base_version=$(extract_base_version_from_image "$stage_image")
    local git_hash=$(extract_git_hash_from_image "$stage_image")
    local registry="${stage_image%%:*}"
    echo "${registry}:${base_version}-${git_hash}"
}

# Extract image tags from current env.cue on a branch
# Note: If EXAMPLE_APP_IMAGE_OVERRIDE is set, it will be used instead of
# extracting from the branch. This handles version alignment (e.g., when
# prod was rolled back and needs to be re-aligned with stage).
extract_images_from_env_cue() {
    local env="$1"
    local gitlab_cli="$SCRIPT_DIR/../04-operations/gitlab-cli.sh"

    # Check for image override (set by version consistency check)
    if [[ -n "${EXAMPLE_APP_IMAGE_OVERRIDE:-}" ]]; then
        EXAMPLE_APP_IMAGE="$EXAMPLE_APP_IMAGE_OVERRIDE"
        log_info "  exampleApp image: $EXAMPLE_APP_IMAGE (override for version alignment)"
    else
        local content=$("$gitlab_cli" file get "$DEPLOYMENTS_REPO_PATH" env.cue --ref "$env" 2>/dev/null)

        # Extract exampleApp image - look for image in the exampleApp block
        # Pattern: after "exampleApp:" find the first "image:" line
        EXAMPLE_APP_IMAGE=$(echo "$content" | awk '
            /exampleApp:.*\{/ { in_example=1 }
            in_example && /image:/ {
                gsub(/.*image:[[:space:]]*"/, "")
                gsub(/".*/, "")
                print
                exit
            }
        ')

        # Fallback to seed placeholder if extraction failed (first run before any CI/CD build)
        if [[ -z "$EXAMPLE_APP_IMAGE" ]]; then
            log_warn "Could not extract exampleApp image from $env, using does-not-exist placeholder"
            EXAMPLE_APP_IMAGE="${DOCKER_REGISTRY_HOST:?DOCKER_REGISTRY_HOST not set}/${CONTAINER_REGISTRY_PATH_PREFIX:?CONTAINER_REGISTRY_PATH_PREFIX not set}/example-app:does-not-exist"
        fi

        log_info "  exampleApp image: $EXAMPLE_APP_IMAGE"
    fi

    # Postgres image is always extracted from the branch (no override needed)
    local content=$("$gitlab_cli" file get "$DEPLOYMENTS_REPO_PATH" env.cue --ref "$env" 2>/dev/null)
    POSTGRES_IMAGE=$(echo "$content" | awk '
        /postgres:.*\{/ { in_postgres=1 }
        in_postgres && /image:/ {
            gsub(/.*image:[[:space:]]*"/, "")
            gsub(/".*/, "")
            print
            exit
        }
    ')

    if [[ -z "$POSTGRES_IMAGE" ]]; then
        POSTGRES_IMAGE="postgres:16-alpine"
    fi

    log_info "  postgres image: $POSTGRES_IMAGE"
}


# =============================================================================
# Phase 3: Reset CUE Configuration via MR Workflow
# =============================================================================

# Reset a single environment using MR workflow
# Usage: reset_env_via_mr <env>
# This creates a feature branch, commits all reset files, creates MR,
# waits for Jenkins to regenerate manifests, and merges.
reset_env_via_mr() {
    local env="$1"
    local timestamp=$(date +%s)
    local branch_name="reset-demo-${env}-${timestamp}"

    log_info ""
    log_info "=== Resetting $env branch via MR workflow ==="

    # 1. Extract current images (to preserve CI/CD-managed values)
    extract_images_from_env_cue "$env"

    # 2. Gather all files to reset
    local files_to_commit=()

    # 2a. Get services/ files from main
    local encoded_project=$(echo "$DEPLOYMENTS_REPO_PATH" | sed 's/\//%2F/g')
    local tree_url="$GITLAB_URL_EXTERNAL/api/v4/projects/$encoded_project/repository/tree?ref=main&path=services&recursive=true&per_page=100"
    local service_files=$(curl -sk -H "PRIVATE-TOKEN: $GITLAB_TOKEN" "$tree_url" 2>/dev/null | \
        jq -r '.[] | select(.type == "blob") | .path')

    for file_path in $service_files; do
        local content=$(mw_get_file "$DEPLOYMENTS_REPO_PATH" "main" "$file_path")
        if [[ -n "$content" ]]; then
            local content_b64=$(echo "$content" | base64 -w0)
            files_to_commit+=("$file_path:base64:$content_b64")
        fi
    done
    log_info "  Prepared ${#files_to_commit[@]} files from services/"

    # 2b. Get Jenkinsfile from main
    local jenkinsfile_content=$(mw_get_file "$DEPLOYMENTS_REPO_PATH" "main" "Jenkinsfile")
    if [[ -n "$jenkinsfile_content" ]]; then
        local jenkinsfile_b64=$(echo "$jenkinsfile_content" | base64 -w0)
        files_to_commit+=("Jenkinsfile:base64:$jenkinsfile_b64")
        log_info "  Prepared Jenkinsfile"
    fi

    # 2c. Get scripts/ files from main
    tree_url="$GITLAB_URL_EXTERNAL/api/v4/projects/$encoded_project/repository/tree?ref=main&path=scripts&recursive=true&per_page=100"
    local script_files=$(curl -sk -H "PRIVATE-TOKEN: $GITLAB_TOKEN" "$tree_url" 2>/dev/null | \
        jq -r '.[] | select(.type == "blob") | .path')

    local script_count=0
    for file_path in $script_files; do
        local content=$(mw_get_file "$DEPLOYMENTS_REPO_PATH" "main" "$file_path")
        if [[ -n "$content" ]]; then
            local content_b64=$(echo "$content" | base64 -w0)
            files_to_commit+=("$file_path:base64:$content_b64")
            script_count=$((script_count + 1))
        fi
    done
    log_info "  Prepared $script_count files from scripts/"

    # 2d. Generate env.cue from baseline
    local baseline_file="$BASELINES_DIR/env-${env}.cue"
    if [[ -f "$baseline_file" ]]; then
        # Get cluster-specific namespace for this environment
        local ns_var="${env^^}_NAMESPACE"  # DEV_NAMESPACE, STAGE_NAMESPACE, PROD_NAMESPACE
        local target_namespace="${!ns_var:?${ns_var} not set in cluster config}"

        local env_cue_content=$(cat "$baseline_file" \
            | sed "s|{{EXAMPLE_APP_IMAGE}}|$EXAMPLE_APP_IMAGE|g" \
            | sed "s|{{POSTGRES_IMAGE}}|$POSTGRES_IMAGE|g" \
            | sed "s|namespace: \"${env}\"|namespace: \"${target_namespace}\"|g" \
            | sed "s|redis.${env}.svc|redis.${target_namespace}.svc|g")
        local env_cue_b64=$(echo "$env_cue_content" | base64 -w0)
        files_to_commit+=("env.cue:base64:$env_cue_b64")
        log_info "  Prepared env.cue from baseline (namespace: $target_namespace)"
    fi

    # 3. Execute MR workflow
    log_info "  Creating feature branch and MR..."

    local title="chore: reset $env to baseline [no-promote]"
    local commit_message="chore: reset $env CUE configuration to baseline [no-promote]

Resets services/, scripts/, Jenkinsfile, and env.cue from main.
Preserves CI/CD-managed image tags.

Automated reset by reset-demo-state.sh"

    if mw_complete_mr_workflow \
        "$DEPLOYMENTS_REPO_PATH" \
        "$env" \
        "$branch_name" \
        "$title" \
        "$commit_message" \
        "${files_to_commit[@]}"; then
        log_info "  ✓ MR !$MW_RESULT_MR_IID merged to $env"
        return 0
    else
        log_error "  ✗ Failed to create/merge MR for $env"
        return 1
    fi
}

# Wait for env branch to be quiescent (no queued or running builds) and verify success
# This is simpler than waiting for a specific NEW build - we just wait for whatever
# is running/queued to finish, then verify the last build succeeded.
# Usage: wait_for_env_quiescence <env> [timeout]
# Returns: 0 if quiescent and last build succeeded, 1 if failed or timeout
wait_for_env_quiescence() {
    local env="$1"
    local timeout="${2:-180}"
    local jenkins_cli="$SCRIPT_DIR/../04-operations/jenkins-cli.sh"
    local start_time=$(date +%s)

    log_info "  Waiting for $env to be quiescent..."

    # Brief delay to allow merge webhook to be processed
    # GitLab webhook → Jenkins → queue the build takes a few seconds
    sleep 5

    while true; do
        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))

        if [[ $elapsed -ge $timeout ]]; then
            log_error "  ✗ Quiescence timeout for $env after ${timeout}s"
            return 1
        fi

        # Check if build is running
        local status_json=$("$jenkins_cli" status "k8s-deployments/$env" 2>/dev/null || echo '{}')
        local building=$(echo "$status_json" | jq -r '.building // false')

        # Check queue for this branch
        local queue_json=$(curl -sk -u "$JENKINS_USER:$JENKINS_TOKEN" \
            "$JENKINS_URL_EXTERNAL/queue/api/json" 2>/dev/null || echo '{"items":[]}')
        local queued=$(echo "$queue_json" | jq -r --arg env "$env" \
            '[.items[] | select(.task.name == $env)] | length')

        if [[ "$building" == "false" ]] && [[ "$queued" == "0" ]]; then
            # Verify the last build succeeded
            local last_result=$(echo "$status_json" | jq -r '.result // empty')
            if [[ "$last_result" != "SUCCESS" ]]; then
                # Check for first-run condition: does-not-exist image tag means no deployable
                # image exists yet. The pipeline will fail at ArgoCD sync, which is expected.
                if [[ "${EXAMPLE_APP_IMAGE:-}" == *":does-not-exist" ]]; then
                    log_info "  ⊘ $env build result: $last_result (expected - image tag 'does-not-exist' means no image available yet)"
                    return 0
                fi
                log_error "  ✗ $env build failed (result: $last_result)"
                return 1
            fi
            log_info "  ✓ $env is quiescent (last build: SUCCESS)"
            return 0
        fi

        local status_msg=""
        [[ "$building" == "true" ]] && status_msg="running"
        [[ "$queued" != "0" ]] && status_msg="${status_msg:+$status_msg, }queued"
        log_info "  $env: $status_msg (${elapsed}s elapsed)"

        sleep 10
    done
}

# Main Phase 3 function: Reset all CUE configuration via MR workflow
reset_cue_config() {
    log_step "Phase 3: Resetting CUE configuration via MR workflow..."
    log_info ""
    log_info "This uses the standard MR workflow for each environment:"
    log_info "  feature branch → commit changes → MR → Jenkins CI → merge → quiescence"
    log_info ""

    local failed_envs=()

    # Version consistency check: If resetting both stage and prod, ensure prod
    # has the same git hash as stage. This handles the case where prod was
    # rolled back (e.g., UC-E4) and now has an older version than stage.
    # Without this fix, promoting to prod fails because the release artifact
    # already exists in Nexus with a different git hash.
    local prod_image_override=""
    if [[ " ${BRANCH_LIST[*]} " =~ " stage " ]] && [[ " ${BRANCH_LIST[*]} " =~ " prod " ]]; then
        log_info "Checking version consistency between stage and prod..."
        local gitlab_cli="$SCRIPT_DIR/../04-operations/gitlab-cli.sh"

        # Extract stage image
        local stage_content=$("$gitlab_cli" file get "$DEPLOYMENTS_REPO_PATH" env.cue --ref "stage" 2>/dev/null)
        local stage_image=$(echo "$stage_content" | awk '
            /exampleApp:.*\{/ { in_example=1 }
            in_example && /image:/ {
                gsub(/.*image:[[:space:]]*"/, "")
                gsub(/".*/, "")
                print
                exit
            }
        ')

        # Extract prod image
        local prod_content=$("$gitlab_cli" file get "$DEPLOYMENTS_REPO_PATH" env.cue --ref "prod" 2>/dev/null)
        local prod_image=$(echo "$prod_content" | awk '
            /exampleApp:.*\{/ { in_example=1 }
            in_example && /image:/ {
                gsub(/.*image:[[:space:]]*"/, "")
                gsub(/".*/, "")
                print
                exit
            }
        ')

        local stage_hash=$(extract_git_hash_from_image "$stage_image")
        local prod_hash=$(extract_git_hash_from_image "$prod_image")

        if [[ -n "$stage_hash" ]] && [[ -n "$prod_hash" ]] && [[ "$stage_hash" != "$prod_hash" ]]; then
            log_warn "Version mismatch detected: stage hash=$stage_hash, prod hash=$prod_hash"
            log_info "  Prod was likely rolled back. Aligning prod to match stage's git hash."
            prod_image_override=$(convert_stage_image_to_prod_format "$stage_image")
            log_info "  Prod image override: $prod_image_override"
        else
            log_info "  ✓ Stage and prod have consistent git hashes"
        fi
    fi

    for env in "${BRANCH_LIST[@]}"; do
        # Step 1: Create MR and merge (waits for feature branch pipeline)
        # Pass prod image override if set
        if [[ "$env" == "prod" ]] && [[ -n "$prod_image_override" ]]; then
            EXAMPLE_APP_IMAGE_OVERRIDE="$prod_image_override"
        else
            EXAMPLE_APP_IMAGE_OVERRIDE=""
        fi

        if ! reset_env_via_mr "$env"; then
            failed_envs+=("$env")
            continue
        fi

        # Step 2: Wait for pipeline quiescence
        # After merge, webhooks trigger env branch builds. Wait for them to complete
        # so the next demo's preflight check passes (no running/queued builds).
        # This is simpler than tracking specific build timestamps.
        if ! wait_for_env_quiescence "$env" 180; then
            failed_envs+=("$env")
        fi
    done

    if [[ ${#failed_envs[@]} -gt 0 ]]; then
        log_error "Failed to reset environments: ${failed_envs[*]}"
        return 1
    fi

    log_info ""
    log_info "CUE configuration reset complete - all environments verified"
}

# =============================================================================
# Main
# =============================================================================
main() {
    echo "=== Reset Demo State ==="
    echo ""
    echo "This script establishes a well-defined starting point for demos"
    echo "by resetting CUE configuration to canonical baselines."
    echo ""
    echo "CLEAN STARTING POINT:"
    echo "  - Jenkins queue cleared (no stale running/queued jobs)"
    echo "  - No stale local demo branches"
    echo "  - No orphaned GitLab demo branches"
    echo "  - No open MRs targeting dev, stage, or prod branches"
    echo "  - services/ directory reset from main"
    echo "  - env.cue reset to baseline (preserving CI/CD images)"
    echo "  - Manifests regenerated by Jenkins"
    if [[ "$RESET_EXAMPLE_APP" == "true" ]]; then
        echo "  - example-app demo artifacts cleaned (UC-E2, etc.)"
    fi
    echo ""

    log_step "Credentials loaded via mr-workflow.sh"
    log_info "GitLab: $GITLAB_URL_EXTERNAL"
    log_info "Jenkins: $JENKINS_URL_EXTERNAL"

    # Phase 0: Wait for pipeline quiescence before any cleanup
    # This prevents race conditions with auto-promote webhooks from previous demos
    wait_for_pipeline_quiescence 120

    # Phase 1: Clean up Jenkins
    cleanup_jenkins_queue

    # Phase 2: Clean up branches and MRs
    log_step "Phase 2: Cleaning up branches and MRs..."
    cleanup_local_branches
    close_all_env_mrs "$DEPLOYMENTS_REPO_PATH"
    cleanup_gitlab_orphan_branches "$DEPLOYMENTS_REPO_PATH"

    # Phase 2b: Clean up example-app (optional)
    # NOTE: This creates an MR on GitLab, which may trigger Jenkins builds.
    # Any code change to example-app/main triggers Jenkins to build a new image
    # and create an MR to k8s-deployments.
    if [[ "$RESET_EXAMPLE_APP" == "true" ]]; then
        cleanup_example_app

        # The cleanup MR merge triggers Jenkins → builds new image → creates MR to k8s-deployments
        # We must wait for:
        # 1. example-app/main build to complete (this is what creates the MR!)
        # 2. k8s-deployments to be quiescent (any triggered builds)
        # 3. Close any MRs created by the cascade
        log_info ""
        log_info "Waiting for example-app cleanup cascade to complete..."

        # Step 1: Wait for example-app build to complete
        # This is critical - the MR is created at the END of this build
        wait_for_example_app_build 300

        # Step 2: Wait for any k8s-deployments builds that might have been triggered
        wait_for_pipeline_quiescence 180

        # Step 3: Close any MRs created by the cleanup cascade
        # The MR should exist now since we waited for the example-app build
        log_info "Closing any MRs created by cleanup cascade..."
        close_all_env_mrs "$DEPLOYMENTS_REPO_PATH"
    fi

    # Phase 3: Reset CUE configuration
    reset_cue_config

    # Phase 4: Final cleanup - catch any MRs created during reset or left from previous tests
    # This is a safety net for MRs that slipped through earlier cleanup phases
    # The cleanup cascade may have created MRs during Phase 3 that need to be closed
    log_info ""
    log_info "Phase 4: Final verification and cleanup..."

    # Wait for full quiescence - this catches any builds started during Phase 3
    # (e.g., example-app cleanup cascade that created MRs after the earlier close check)
    wait_for_pipeline_quiescence 120

    # Now close any MRs that were created during the reset process
    local final_mrs=$("$SCRIPT_DIR/../04-operations/gitlab-cli.sh" mr list "$DEPLOYMENTS_REPO_PATH" --state opened 2>/dev/null | jq -r '.[].iid // empty' 2>/dev/null)
    if [[ -n "$final_mrs" ]]; then
        log_info "Closing MRs created during reset process..."
        close_all_env_mrs "$DEPLOYMENTS_REPO_PATH"
    fi

    echo ""
    echo "=== Reset Complete ==="
    echo ""
    log_info "Clean starting point established:"
    log_info "  - Jenkins queue cleared, agent pods deleted"
    log_info "  - Local demo branches cleaned up"
    log_info "  - All env-targeting MRs closed"
    log_info "  - Orphaned GitLab demo branches deleted"
    if [[ "$RESET_EXAMPLE_APP" == "true" ]]; then
        log_info "  - example-app demo artifacts cleaned"
    fi
    log_info "  - services/ directory reset from main"
    log_info "  - env.cue reset to baseline (preserving CI/CD images)"
    log_info "  - Manifests regenerated by Jenkins"
    echo ""
    log_info "Next steps:"
    log_info "  1. Commit any local changes: git add -A && git commit -m 'chore: reset demo state'"
    log_info "  2. Push to GitHub: git push origin main"
    log_info "  3. Run validation: ./scripts/demo/run-all-demos.sh"
    log_info "  4. Run demo: ./scripts/demo/demo-uc-c1-default-label.sh"
}

main "$@"
