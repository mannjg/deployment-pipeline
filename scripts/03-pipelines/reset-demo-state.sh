#!/usr/bin/env bash
#
# Reset Demo State
#
# Establishes a well-defined starting point for demos by resetting CUE
# configuration to canonical baselines while preserving CI/CD-managed images.
#
# Usage:
#   ./scripts/03-pipelines/reset-demo-state.sh
#
# Clean Starting Point:
#   - Jenkins queue cleared (no stale running/queued jobs)
#   - No stale local demo branches (uc-*, update-dev-*, promote-*)
#   - No orphaned GitLab demo branches
#   - No open MRs targeting dev, stage, or prod branches
#   - services/ directory reset to main branch (all CUE definitions)
#   - env.cue reset to baseline (preserving CI/CD-managed images)
#   - Manifests regenerated by Jenkins from clean CUE
#   - App version at 1.0.0-SNAPSHOT
#
# What it preserves:
#   - CI/CD-managed image tags in env.cue
#   - Environment branches (dev, stage, prod, main)
#
# Baseline files: scripts/03-pipelines/baselines/env-{dev,stage,prod}.cue
#

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() { echo -e "${GREEN}[INFO]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*"; }
log_step() { echo -e "\n${BLUE}[->]${NC} $*"; }

# Load infrastructure config
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
BASELINES_DIR="$SCRIPT_DIR/baselines"

if [[ -f "$REPO_ROOT/config/infra.env" ]]; then
    source "$REPO_ROOT/config/infra.env"
else
    log_error "Cannot find config/infra.env"
    exit 1
fi

# =============================================================================
# Get Credentials
# =============================================================================
get_credentials() {
    log_step "Loading credentials..."

    # Get GITLAB_TOKEN (env var or K8s secret)
    GITLAB_TOKEN="${GITLAB_TOKEN:-}"
    if [[ -z "$GITLAB_TOKEN" ]]; then
        GITLAB_TOKEN=$(kubectl get secret "${GITLAB_API_TOKEN_SECRET}" -n "${GITLAB_NAMESPACE}" \
            -o jsonpath="{.data.${GITLAB_API_TOKEN_KEY}}" 2>/dev/null | base64 -d) || true
    fi

    if [[ -z "$GITLAB_TOKEN" ]]; then
        log_error "GITLAB_TOKEN not set and could not retrieve from K8s secret"
        exit 1
    fi

    # Get Jenkins credentials
    JENKINS_USER="${JENKINS_USER:-}"
    JENKINS_TOKEN="${JENKINS_TOKEN:-}"
    if [[ -z "$JENKINS_USER" ]]; then
        JENKINS_USER=$(kubectl get secret "${JENKINS_ADMIN_SECRET}" -n "${JENKINS_NAMESPACE}" \
            -o jsonpath="{.data.${JENKINS_ADMIN_USER_KEY}}" 2>/dev/null | base64 -d) || true
    fi
    if [[ -z "$JENKINS_TOKEN" ]]; then
        JENKINS_TOKEN=$(kubectl get secret "${JENKINS_ADMIN_SECRET}" -n "${JENKINS_NAMESPACE}" \
            -o jsonpath="{.data.${JENKINS_ADMIN_TOKEN_KEY}}" 2>/dev/null | base64 -d) || true
    fi

    GITLAB_URL="https://${GITLAB_HOST_EXTERNAL}"
    JENKINS_URL="${JENKINS_URL_EXTERNAL:-http://jenkins.local}"
    log_info "GitLab: $GITLAB_URL"
    log_info "Jenkins: $JENKINS_URL"
}

# =============================================================================
# Phase 1: Clean up Jenkins queue and running jobs
# =============================================================================
cleanup_jenkins_queue() {
    log_step "Phase 1: Cleaning up Jenkins queue and running jobs..."

    if [[ -z "$JENKINS_USER" ]] || [[ -z "$JENKINS_TOKEN" ]]; then
        log_warn "Jenkins credentials not available, skipping queue cleanup"
        return 0
    fi

    local jenkins_auth="$JENKINS_USER:$JENKINS_TOKEN"

    # Fetch Jenkins CRUMB for CSRF protection
    local crumb_response=$(curl -sk -u "$jenkins_auth" "$JENKINS_URL/crumbIssuer/api/json" 2>/dev/null)
    local crumb_field=$(echo "$crumb_response" | jq -r '.crumbRequestField // empty' 2>/dev/null)
    local crumb_value=$(echo "$crumb_response" | jq -r '.crumb // empty' 2>/dev/null)

    if [[ -z "$crumb_field" ]] || [[ -z "$crumb_value" ]]; then
        log_warn "Could not fetch Jenkins CRUMB, POST operations may fail"
        local crumb_header=""
    else
        local crumb_header="-H $crumb_field:$crumb_value"
    fi

    # 1. Cancel all queued items
    log_info "Canceling queued Jenkins jobs..."
    local queue_items=$(curl -sk -u "$jenkins_auth" "$JENKINS_URL/queue/api/json" 2>/dev/null | \
        jq -r '.items[].id' 2>/dev/null || true)

    local canceled=0
    if [[ -n "$queue_items" ]]; then
        for item_id in $queue_items; do
            curl -sk -X POST -u "$jenkins_auth" $crumb_header \
                "$JENKINS_URL/queue/cancelItem?id=$item_id" >/dev/null 2>&1 && \
                canceled=$((canceled + 1))
        done
    fi
    log_info "  Canceled $canceled queued items"

    # 2. Abort running builds for k8s-deployments branches
    log_info "Aborting running Jenkins builds..."
    local aborted=0

    local jobs=$(curl -sk -u "$jenkins_auth" "$JENKINS_URL/job/k8s-deployments/api/json" 2>/dev/null | \
        jq -r '.jobs[].name' 2>/dev/null || true)

    if [[ -n "$jobs" ]]; then
        for job_name in $jobs; do
            local encoded_job=$(echo "$job_name" | jq -sRr @uri)
            local builds=$(curl -sk -u "$jenkins_auth" \
                "$JENKINS_URL/job/k8s-deployments/job/$encoded_job/api/json" 2>/dev/null | \
                jq -r '.builds[]? | select(.building == true) | .number' 2>/dev/null || true)

            for build_num in $builds; do
                if [[ -n "$build_num" ]]; then
                    curl -sk -X POST -u "$jenkins_auth" $crumb_header \
                        "$JENKINS_URL/job/k8s-deployments/job/$encoded_job/$build_num/stop" >/dev/null 2>&1 && \
                        aborted=$((aborted + 1))
                fi
            done
        done
    fi
    log_info "  Aborted $aborted running builds"

    # 3. Delete all Jenkins agent pods
    log_info "Deleting Jenkins agent pods..."
    local deleted_pods=$(kubectl get pods -n "${JENKINS_NAMESPACE}" --no-headers -o custom-columns=NAME:.metadata.name 2>/dev/null | \
        grep -v "^jenkins-" | wc -l)

    kubectl get pods -n "${JENKINS_NAMESPACE}" --no-headers -o custom-columns=NAME:.metadata.name 2>/dev/null | \
        grep -v "^jenkins-" | \
        xargs -r kubectl delete pod -n "${JENKINS_NAMESPACE}" --force --grace-period=0 >/dev/null 2>&1 || true

    log_info "  Deleted $deleted_pods agent pods"

    # 4. Wait for Jenkins to stabilize
    log_info "Waiting for Jenkins to stabilize..."
    sleep 5
}

# =============================================================================
# Phase 2: Clean up branches and MRs
# =============================================================================
cleanup_local_branches() {
    log_info "Cleaning up local demo branches..."

    local patterns=("uc-*" "update-dev-*" "promote-*" "sync-main-*")
    local deleted=0

    for pattern in "${patterns[@]}"; do
        local branches=$(git branch --list "$pattern" 2>/dev/null | sed 's/^[* ]*//')
        if [[ -n "$branches" ]]; then
            while IFS= read -r branch; do
                if [[ -n "$branch" ]]; then
                    git branch -D "$branch" >/dev/null 2>&1 && deleted=$((deleted + 1))
                fi
            done <<< "$branches"
        fi
    done

    if [[ $deleted -gt 0 ]]; then
        log_info "  Deleted $deleted local demo branches"
    else
        log_info "  No local demo branches to clean"
    fi
}

cleanup_gitlab_orphan_branches() {
    local project_path="$1"
    local gitlab_cli="$SCRIPT_DIR/../04-operations/gitlab-cli.sh"

    log_info "Cleaning up orphaned GitLab demo branches..."

    local patterns=("uc-" "update-dev-" "promote-" "sync-main-")
    local deleted=0

    for pattern in "${patterns[@]}"; do
        local branches
        if branches=$("$gitlab_cli" branch list "$project_path" --pattern "${pattern}*" 2>/dev/null); then
            while IFS= read -r branch; do
                if [[ -n "$branch" ]]; then
                    if "$gitlab_cli" branch delete "$project_path" "$branch" >/dev/null 2>&1; then
                        deleted=$((deleted + 1))
                    fi
                fi
            done <<< "$branches"
        fi
    done

    if [[ $deleted -gt 0 ]]; then
        log_info "  Deleted $deleted orphaned GitLab demo branches"
    else
        log_info "  No orphaned GitLab demo branches to clean"
    fi
}

close_all_env_mrs() {
    local project_path="$1"
    local gitlab_cli="$SCRIPT_DIR/../04-operations/gitlab-cli.sh"

    log_info "Closing ALL open MRs targeting environment branches..."

    for target_branch in dev stage prod; do
        local mr_list
        if ! mr_list=$("$gitlab_cli" mr list "$project_path" --state opened --target "$target_branch" 2>/dev/null); then
            log_info "  $target_branch: no open MRs"
            continue
        fi

        local all_mrs=$(echo "$mr_list" | jq -r '"\(.iid):\(.source_branch)"' 2>/dev/null)

        if [[ -z "$all_mrs" ]]; then
            log_info "  $target_branch: no open MRs"
            continue
        fi

        local count=0
        while IFS=: read -r mr_iid source_branch; do
            if [[ -n "$mr_iid" ]]; then
                log_info "  Closing MR !$mr_iid ($source_branch â†’ $target_branch)..."
                "$gitlab_cli" mr close "$project_path" "$mr_iid" >/dev/null 2>&1 || true

                # Delete source branch if it's not an environment branch
                if [[ "$source_branch" != "dev" && "$source_branch" != "stage" && "$source_branch" != "prod" && "$source_branch" != "main" ]]; then
                    "$gitlab_cli" branch delete "$project_path" "$source_branch" >/dev/null 2>&1 || true
                fi

                count=$((count + 1))
            fi
        done <<< "$all_mrs"

        log_info "  $target_branch: closed $count MRs"
    done
}

# =============================================================================
# Phase 3: Reset CUE Configuration (Baseline Approach)
# =============================================================================

# Extract image tags from current env.cue on a branch
extract_images_from_env_cue() {
    local env="$1"
    local gitlab_cli="$SCRIPT_DIR/../04-operations/gitlab-cli.sh"

    local content=$("$gitlab_cli" file get "$DEPLOYMENTS_REPO_PATH" env.cue --ref "$env" 2>/dev/null)

    # Extract exampleApp image - look for image in the exampleApp block
    # Pattern: after "exampleApp:" find the first "image:" line
    EXAMPLE_APP_IMAGE=$(echo "$content" | awk '
        /exampleApp:.*\{/ { in_example=1 }
        in_example && /image:/ {
            gsub(/.*image:[[:space:]]*"/, "")
            gsub(/".*/, "")
            print
            exit
        }
    ')

    # Extract postgres image - look for image in the postgres block
    POSTGRES_IMAGE=$(echo "$content" | awk '
        /postgres:.*\{/ { in_postgres=1 }
        in_postgres && /image:/ {
            gsub(/.*image:[[:space:]]*"/, "")
            gsub(/".*/, "")
            print
            exit
        }
    ')

    # Fallback to defaults if extraction failed
    if [[ -z "$EXAMPLE_APP_IMAGE" ]]; then
        log_warn "Could not extract exampleApp image from $env, using placeholder"
        EXAMPLE_APP_IMAGE="docker.jmann.local/p2c/example-app:latest"
    fi

    if [[ -z "$POSTGRES_IMAGE" ]]; then
        POSTGRES_IMAGE="postgres:16-alpine"
    fi

    log_info "  exampleApp image: $EXAMPLE_APP_IMAGE"
    log_info "  postgres image: $POSTGRES_IMAGE"
}

# Reset services/ directory from main branch
reset_services_directory() {
    local env="$1"
    local gitlab_cli="$SCRIPT_DIR/../04-operations/gitlab-cli.sh"
    local encoded_project=$(echo "$DEPLOYMENTS_REPO_PATH" | sed 's/\//%2F/g')

    log_info "Resetting services/ directory on $env from main..."

    # Get list of files in services/ from main branch (recursive)
    local tree_url="$GITLAB_URL/api/v4/projects/$encoded_project/repository/tree?ref=main&path=services&recursive=true&per_page=100"
    local files=$(curl -sk -H "PRIVATE-TOKEN: $GITLAB_TOKEN" "$tree_url" 2>/dev/null | \
        jq -r '.[] | select(.type == "blob") | .path')

    if [[ -z "$files" ]]; then
        log_warn "Could not list files in services/ directory"
        return 1
    fi

    local updated=0
    for file_path in $files; do
        local encoded_file=$(echo "$file_path" | sed 's/\//%2F/g')

        # Get content from main
        local main_content=$(curl -sk -H "PRIVATE-TOKEN: $GITLAB_TOKEN" \
            "$GITLAB_URL/api/v4/projects/$encoded_project/repository/files/$encoded_file?ref=main" 2>/dev/null)

        if [[ -z "$main_content" ]] || ! echo "$main_content" | jq -e '.content' > /dev/null 2>&1; then
            continue
        fi

        local content_b64=$(echo "$main_content" | jq -r '.content')

        # Update file on env branch
        local result=$(curl -sk -X PUT -H "PRIVATE-TOKEN: $GITLAB_TOKEN" \
            -H "Content-Type: application/json" \
            -d "{\"branch\": \"$env\", \"encoding\": \"base64\", \"content\": \"$content_b64\", \"commit_message\": \"chore: reset $file_path from main for demo\"}" \
            "$GITLAB_URL/api/v4/projects/$encoded_project/repository/files/$encoded_file" 2>/dev/null)

        if echo "$result" | jq -e '.file_path' > /dev/null 2>&1; then
            updated=$((updated + 1))
        fi
    done

    log_info "  Updated $updated files in services/"
}

# Reset Jenkinsfile from main branch
reset_jenkinsfile() {
    local env="$1"
    local encoded_project=$(echo "$DEPLOYMENTS_REPO_PATH" | sed 's/\//%2F/g')

    log_info "Resetting Jenkinsfile on $env from main..."

    local encoded_file="Jenkinsfile"

    # Get content from main
    local main_content=$(curl -sk -H "PRIVATE-TOKEN: $GITLAB_TOKEN" \
        "$GITLAB_URL/api/v4/projects/$encoded_project/repository/files/$encoded_file?ref=main" 2>/dev/null)

    if [[ -z "$main_content" ]] || ! echo "$main_content" | jq -e '.content' > /dev/null 2>&1; then
        log_warn "Could not get Jenkinsfile from main"
        return 1
    fi

    local content_b64=$(echo "$main_content" | jq -r '.content')

    # Update on env branch
    local result=$(curl -sk -X PUT -H "PRIVATE-TOKEN: $GITLAB_TOKEN" \
        -H "Content-Type: application/json" \
        -d "{\"branch\": \"$env\", \"encoding\": \"base64\", \"content\": \"$content_b64\", \"commit_message\": \"chore: reset Jenkinsfile from main for demo\"}" \
        "$GITLAB_URL/api/v4/projects/$encoded_project/repository/files/$encoded_file" 2>/dev/null)

    if echo "$result" | jq -e '.file_path' > /dev/null 2>&1; then
        log_info "  Jenkinsfile updated"
    fi
}

# Reset scripts/ directory from main branch
reset_scripts_directory() {
    local env="$1"
    local encoded_project=$(echo "$DEPLOYMENTS_REPO_PATH" | sed 's/\//%2F/g')

    log_info "Resetting scripts/ directory on $env from main..."

    # Get list of files in scripts/ from main branch
    local tree_url="$GITLAB_URL/api/v4/projects/$encoded_project/repository/tree?ref=main&path=scripts&recursive=true&per_page=100"
    local files=$(curl -sk -H "PRIVATE-TOKEN: $GITLAB_TOKEN" "$tree_url" 2>/dev/null | \
        jq -r '.[] | select(.type == "blob") | .path')

    if [[ -z "$files" ]]; then
        log_info "  No scripts/ directory on main"
        return 0
    fi

    local updated=0
    for file_path in $files; do
        local encoded_file=$(echo "$file_path" | sed 's/\//%2F/g')

        # Get content from main
        local main_content=$(curl -sk -H "PRIVATE-TOKEN: $GITLAB_TOKEN" \
            "$GITLAB_URL/api/v4/projects/$encoded_project/repository/files/$encoded_file?ref=main" 2>/dev/null)

        if [[ -z "$main_content" ]] || ! echo "$main_content" | jq -e '.content' > /dev/null 2>&1; then
            continue
        fi

        local content_b64=$(echo "$main_content" | jq -r '.content')

        # Try PUT first (update), fall back to POST (create) if file doesn't exist
        local result=$(curl -sk -X PUT -H "PRIVATE-TOKEN: $GITLAB_TOKEN" \
            -H "Content-Type: application/json" \
            -d "{\"branch\": \"$env\", \"encoding\": \"base64\", \"content\": \"$content_b64\", \"commit_message\": \"chore: reset $file_path from main for demo\"}" \
            "$GITLAB_URL/api/v4/projects/$encoded_project/repository/files/$encoded_file" 2>/dev/null)

        if echo "$result" | jq -e '.file_path' > /dev/null 2>&1; then
            updated=$((updated + 1))
        else
            # Try POST for new files
            result=$(curl -sk -X POST -H "PRIVATE-TOKEN: $GITLAB_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{\"branch\": \"$env\", \"encoding\": \"base64\", \"content\": \"$content_b64\", \"commit_message\": \"chore: add $file_path from main for demo\"}" \
                "$GITLAB_URL/api/v4/projects/$encoded_project/repository/files/$encoded_file" 2>/dev/null)

            if echo "$result" | jq -e '.file_path' > /dev/null 2>&1; then
                updated=$((updated + 1))
            fi
        fi
    done

    log_info "  Updated $updated files in scripts/"
}

# Reset env.cue from baseline template
reset_env_cue_from_baseline() {
    local env="$1"
    local baseline_file="$BASELINES_DIR/env-${env}.cue"
    local encoded_project=$(echo "$DEPLOYMENTS_REPO_PATH" | sed 's/\//%2F/g')

    log_info "Resetting env.cue on $env from baseline..."

    if [[ ! -f "$baseline_file" ]]; then
        log_error "Baseline file not found: $baseline_file"
        return 1
    fi

    # Read baseline and substitute image placeholders
    local content=$(cat "$baseline_file" \
        | sed "s|{{EXAMPLE_APP_IMAGE}}|$EXAMPLE_APP_IMAGE|g" \
        | sed "s|{{POSTGRES_IMAGE}}|$POSTGRES_IMAGE|g")

    # Base64 encode
    local content_b64=$(echo "$content" | base64 -w0)

    # Update on GitLab
    local result=$(curl -sk -X PUT -H "PRIVATE-TOKEN: $GITLAB_TOKEN" \
        -H "Content-Type: application/json" \
        -d "{\"branch\": \"$env\", \"encoding\": \"base64\", \"content\": \"$content_b64\", \"commit_message\": \"chore: reset env.cue to baseline for demo\"}" \
        "$GITLAB_URL/api/v4/projects/$encoded_project/repository/files/env.cue" 2>/dev/null)

    if echo "$result" | jq -e '.file_path' > /dev/null 2>&1; then
        log_info "  env.cue reset to baseline"
    else
        local error=$(echo "$result" | jq -r '.message // "unknown error"' 2>/dev/null)
        log_warn "  Failed to reset env.cue: $error"
    fi
}

# Wait for Jenkins build (using jenkins-cli.sh)
wait_for_build() {
    local job="$1"
    local timeout_seconds="${2:-300}"
    local after_timestamp="${3:-0}"

    local cli_args=("$job" --timeout "$timeout_seconds")
    if [[ $after_timestamp -gt 0 ]]; then
        cli_args+=(--after "$after_timestamp")
    fi

    log_info "  Waiting for build on $job..."

    local result
    if result=$("$SCRIPT_DIR/../04-operations/jenkins-cli.sh" wait "${cli_args[@]}" 2>&1); then
        local build_num
        build_num=$(echo "$result" | tail -1 | jq -r '.number // empty' 2>/dev/null)
        log_info "  Build #${build_num:-?} completed successfully"
        return 0
    else
        log_warn "  Build wait failed or timed out"
        return 1
    fi
}

# Main Phase 3 function: Reset all CUE configuration
reset_cue_config() {
    log_step "Phase 3: Resetting CUE configuration on all environment branches..."

    for env in dev stage prod; do
        log_info ""
        log_info "=== Resetting $env branch ==="

        # 1. Extract current images (to preserve CI/CD-managed values)
        extract_images_from_env_cue "$env"

        # 2. Reset services/ directory from main
        reset_services_directory "$env"

        # 3. Reset Jenkinsfile from main
        reset_jenkinsfile "$env"

        # 4. Reset scripts/ directory from main
        reset_scripts_directory "$env"

        # 5. Reset env.cue from baseline (with extracted images)
        reset_env_cue_from_baseline "$env"
    done

    # 6. Trigger Jenkins builds to regenerate manifests
    log_step "Triggering Jenkins builds to regenerate manifests..."

    local jenkins_auth="$JENKINS_USER:$JENKINS_TOKEN"

    # Trigger multibranch scan
    curl -sk -X POST -u "$jenkins_auth" \
        "$JENKINS_URL/job/k8s-deployments/build?delay=0sec" >/dev/null 2>&1 || true

    # Wait a moment for scan to discover changes
    sleep 10

    # Wait for each environment branch build
    local build_timestamp=$(($(date +%s) * 1000))
    for env in dev stage prod; do
        wait_for_build "k8s-deployments/$env" 300 "$build_timestamp" || true
    done

    # Close any promotion MRs created by the reset builds
    # (These happen because env branches have different images, which triggers promotion logic)
    log_info "Closing any promotion MRs created during reset..."
    local gitlab_cli="$SCRIPT_DIR/../04-operations/gitlab-cli.sh"
    for target in stage prod; do
        local mr_list
        if mr_list=$("$gitlab_cli" mr list "$DEPLOYMENTS_REPO_PATH" --state opened --target "$target" 2>/dev/null); then
            local promote_mrs=$(echo "$mr_list" | jq -r 'select(.source_branch | startswith("promote-")) | .iid' 2>/dev/null)
            for mr_iid in $promote_mrs; do
                if [[ -n "$mr_iid" ]]; then
                    "$gitlab_cli" mr close "$DEPLOYMENTS_REPO_PATH" "$mr_iid" >/dev/null 2>&1 || true
                    log_info "  Closed promotion MR !$mr_iid"
                fi
            done
        fi
    done

    # Clean up any orphaned promote-* branches
    local branches
    if branches=$("$gitlab_cli" branch list "$DEPLOYMENTS_REPO_PATH" --pattern "promote-*" 2>/dev/null); then
        while IFS= read -r branch; do
            if [[ -n "$branch" ]]; then
                "$gitlab_cli" branch delete "$DEPLOYMENTS_REPO_PATH" "$branch" >/dev/null 2>&1 || true
            fi
        done <<< "$branches"
    fi

    log_info "CUE configuration reset complete"
}

# =============================================================================
# Phase 5: Reset App Version
# =============================================================================
reset_app_version() {
    local target_version="${1:-1.0.0-SNAPSHOT}"
    local pom_file="$REPO_ROOT/example-app/pom.xml"

    log_step "Phase 5: Resetting app version to $target_version..."

    if [[ ! -f "$pom_file" ]]; then
        log_error "pom.xml not found at $pom_file"
        return 1
    fi

    # Get current version
    local current_version=$(grep -o '<version>[^<]*</version>' "$pom_file" | head -1 | sed 's/<[^>]*>//g')

    if [[ "$current_version" == "$target_version" ]]; then
        log_info "Version already at $target_version"
        return 0
    fi

    log_info "Current version: $current_version"
    log_info "Target version: $target_version"

    # Update the version (first occurrence only)
    sed -i "0,/<version>$current_version<\/version>/s/<version>$current_version<\/version>/<version>$target_version<\/version>/" "$pom_file"

    # Verify the change
    local new_version=$(grep -o '<version>[^<]*</version>' "$pom_file" | head -1 | sed 's/<[^>]*>//g')
    if [[ "$new_version" == "$target_version" ]]; then
        log_info "Version updated successfully"
    else
        log_error "Version update failed"
        return 1
    fi
}

# =============================================================================
# Main
# =============================================================================
main() {
    echo "=== Reset Demo State ==="
    echo ""
    echo "This script establishes a well-defined starting point for demos"
    echo "by resetting CUE configuration to canonical baselines."
    echo ""
    echo "CLEAN STARTING POINT:"
    echo "  - Jenkins queue cleared (no stale running/queued jobs)"
    echo "  - No stale local demo branches"
    echo "  - No orphaned GitLab demo branches"
    echo "  - No open MRs targeting dev, stage, or prod branches"
    echo "  - services/ directory reset from main"
    echo "  - env.cue reset to baseline (preserving CI/CD images)"
    echo "  - Manifests regenerated by Jenkins"
    echo "  - App version at 1.0.0-SNAPSHOT"
    echo ""

    get_credentials

    # Phase 1: Clean up Jenkins
    cleanup_jenkins_queue

    # Phase 2: Clean up branches and MRs
    log_step "Phase 2: Cleaning up branches and MRs..."
    cleanup_local_branches
    close_all_env_mrs "$DEPLOYMENTS_REPO_PATH"
    cleanup_gitlab_orphan_branches "$DEPLOYMENTS_REPO_PATH"

    # Phase 3: Reset CUE configuration
    reset_cue_config

    # Phase 5: Reset app version
    reset_app_version "1.0.0-SNAPSHOT"

    echo ""
    echo "=== Reset Complete ==="
    echo ""
    log_info "Clean starting point established:"
    log_info "  - Jenkins queue cleared, agent pods deleted"
    log_info "  - Local demo branches cleaned up"
    log_info "  - All env-targeting MRs closed"
    log_info "  - Orphaned GitLab demo branches deleted"
    log_info "  - services/ directory reset from main"
    log_info "  - env.cue reset to baseline (preserving CI/CD images)"
    log_info "  - Manifests regenerated by Jenkins"
    log_info "  - App version at 1.0.0-SNAPSHOT"
    echo ""
    log_info "Next steps:"
    log_info "  1. Commit any local changes: git add -A && git commit -m 'chore: reset demo state'"
    log_info "  2. Push to GitHub: git push origin main"
    log_info "  3. Run validation: ./scripts/test/validate-pipeline.sh"
    log_info "  4. Run demo: ./scripts/demo/demo-uc-c1-default-label.sh"
}

main "$@"
