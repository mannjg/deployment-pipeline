#!/usr/bin/env bash
#
# Reset Demo State
#
# Establishes a well-defined starting point for demos by resetting CUE
# configuration to canonical baselines while preserving CI/CD-managed images.
#
# Usage:
#   ./scripts/03-pipelines/reset-demo-state.sh
#
# Clean Starting Point:
#   - Jenkins queue cleared (no stale running/queued jobs)
#   - No stale local demo branches (uc-*, update-dev-*, promote-*)
#   - No orphaned GitLab demo branches
#   - No open MRs targeting dev, stage, or prod branches
#   - services/ directory reset to main branch (all CUE definitions)
#   - env.cue reset to baseline (preserving CI/CD-managed images)
#   - Manifests regenerated by Jenkins from clean CUE
#
# What it preserves:
#   - CI/CD-managed image tags in env.cue
#   - Environment branches (dev, stage, prod, main)
#   - App version in pom.xml (validate-pipeline.sh manages version bumps)
#
# Baseline files: scripts/03-pipelines/baselines/env-{dev,stage,prod}.cue
#

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() { echo -e "${GREEN}[INFO]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*"; }
log_step() { echo -e "\n${BLUE}[->]${NC} $*"; }

# Load infrastructure config
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
BASELINES_DIR="$SCRIPT_DIR/baselines"

# Parse command-line arguments
BRANCHES="dev,stage,prod"  # Default: all branches

while [[ $# -gt 0 ]]; do
    case $1 in
        --branches)
            BRANCHES="$2"
            shift 2
            ;;
        --help|-h)
            echo "Usage: $0 [--branches dev,stage,prod]"
            echo ""
            echo "Options:"
            echo "  --branches  Comma-separated list of branches to reset (default: dev,stage,prod)"
            echo ""
            echo "Examples:"
            echo "  $0                        # Reset all branches"
            echo "  $0 --branches dev         # Reset dev only"
            echo "  $0 --branches dev,stage   # Reset dev and stage"
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Convert comma-separated branches to array
IFS=',' read -ra BRANCH_LIST <<< "$BRANCHES"
log_info "Target branches: ${BRANCH_LIST[*]}"

if [[ -f "$REPO_ROOT/config/infra.env" ]]; then
    source "$REPO_ROOT/config/infra.env"
else
    log_error "Cannot find config/infra.env"
    exit 1
fi

# Set MR workflow configuration (required before sourcing library)
export MR_WORKFLOW_TIMEOUT=600
export MR_WORKFLOW_POLL_INTERVAL=15

# Load MR workflow library
source "$SCRIPT_DIR/../lib/mr-workflow.sh"

# Credentials are loaded by mr-workflow.sh via require_* functions
# GITLAB_TOKEN, JENKINS_USER, JENKINS_TOKEN are now set
# GITLAB_URL_EXTERNAL, JENKINS_URL_EXTERNAL are set by infra.sh

# =============================================================================
# Phase 0: Wait for pipeline quiescence before any cleanup
# =============================================================================
# This prevents a race condition where auto-promote webhooks from the previous
# demo trigger builds while we're deleting agent pods. We must wait for all
# in-flight builds to complete before starting cleanup.
wait_for_pipeline_quiescence() {
    local timeout="${1:-120}"
    local jenkins_cli="$SCRIPT_DIR/../04-operations/jenkins-cli.sh"
    local start_time=$(date +%s)

    log_step "Phase 0: Waiting for pipeline quiescence before cleanup..."
    log_info "Ensuring no builds are in-flight from previous operations..."

    while true; do
        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))

        if [[ $elapsed -ge $timeout ]]; then
            log_warn "Pipeline quiescence timeout after ${timeout}s - proceeding with cleanup"
            return 0  # Don't fail, just warn and proceed
        fi

        local any_active=false
        local status_parts=()

        for env in "${BRANCH_LIST[@]}"; do
            # Check if build is running
            local status_json=$("$jenkins_cli" status "k8s-deployments/$env" 2>/dev/null || echo '{}')
            local building=$(echo "$status_json" | jq -r '.building // false')

            # Check queue for this branch
            local queue_json=$(curl -sk -u "$JENKINS_USER:$JENKINS_TOKEN" \
                "$JENKINS_URL_EXTERNAL/queue/api/json" 2>/dev/null || echo '{"items":[]}')
            local queued=$(echo "$queue_json" | jq -r --arg env "$env" \
                '[.items[] | select(.task.name == $env)] | length')

            if [[ "$building" == "true" ]] || [[ "$queued" != "0" ]]; then
                any_active=true
                local env_status=""
                [[ "$building" == "true" ]] && env_status="running"
                [[ "$queued" != "0" ]] && env_status="${env_status:+$env_status+}queued"
                status_parts+=("$env:$env_status")
            fi
        done

        if [[ "$any_active" == "false" ]]; then
            log_info "  ✓ Pipeline is quiescent - safe to proceed with cleanup"
            return 0
        fi

        log_info "  Waiting for: ${status_parts[*]} (${elapsed}s elapsed)"
        sleep 10
    done
}

# =============================================================================
# Phase 1: Clean up Jenkins queue and running jobs
# =============================================================================
cleanup_jenkins_queue() {
    log_step "Phase 1: Cleaning up Jenkins queue and running jobs..."

    if [[ -z "$JENKINS_USER" ]] || [[ -z "$JENKINS_TOKEN" ]]; then
        log_warn "Jenkins credentials not available, skipping queue cleanup"
        return 0
    fi

    local jenkins_auth="$JENKINS_USER:$JENKINS_TOKEN"

    # Fetch Jenkins CRUMB for CSRF protection
    local crumb_response=$(curl -sk -u "$jenkins_auth" "$JENKINS_URL_EXTERNAL/crumbIssuer/api/json" 2>/dev/null)
    local crumb_field=$(echo "$crumb_response" | jq -r '.crumbRequestField // empty' 2>/dev/null)
    local crumb_value=$(echo "$crumb_response" | jq -r '.crumb // empty' 2>/dev/null)

    if [[ -z "$crumb_field" ]] || [[ -z "$crumb_value" ]]; then
        log_warn "Could not fetch Jenkins CRUMB, POST operations may fail"
        local crumb_header=""
    else
        local crumb_header="-H $crumb_field:$crumb_value"
    fi

    # 1. Cancel all queued items
    log_info "Canceling queued Jenkins jobs..."
    local queue_items=$(curl -sk -u "$jenkins_auth" "$JENKINS_URL_EXTERNAL/queue/api/json" 2>/dev/null | \
        jq -r '.items[].id' 2>/dev/null || true)

    local canceled=0
    if [[ -n "$queue_items" ]]; then
        for item_id in $queue_items; do
            curl -sk -X POST -u "$jenkins_auth" $crumb_header \
                "$JENKINS_URL_EXTERNAL/queue/cancelItem?id=$item_id" >/dev/null 2>&1 && \
                canceled=$((canceled + 1))
        done
    fi
    log_info "  Canceled $canceled queued items"

    # 2. Abort running builds for k8s-deployments branches
    log_info "Aborting running Jenkins builds..."
    local aborted=0

    local jobs=$(curl -sk -u "$jenkins_auth" "$JENKINS_URL_EXTERNAL/job/k8s-deployments/api/json" 2>/dev/null | \
        jq -r '.jobs[].name' 2>/dev/null || true)

    if [[ -n "$jobs" ]]; then
        for job_name in $jobs; do
            local encoded_job=$(echo "$job_name" | jq -sRr @uri)
            local builds=$(curl -sk -u "$jenkins_auth" \
                "$JENKINS_URL_EXTERNAL/job/k8s-deployments/job/$encoded_job/api/json" 2>/dev/null | \
                jq -r '.builds[]? | select(.building == true) | .number' 2>/dev/null || true)

            for build_num in $builds; do
                if [[ -n "$build_num" ]]; then
                    curl -sk -X POST -u "$jenkins_auth" $crumb_header \
                        "$JENKINS_URL_EXTERNAL/job/k8s-deployments/job/$encoded_job/$build_num/stop" >/dev/null 2>&1 && \
                        aborted=$((aborted + 1))
                fi
            done
        done
    fi
    log_info "  Aborted $aborted running builds"

    # 3. Delete all Jenkins agent pods
    log_info "Deleting Jenkins agent pods..."
    local deleted_pods=$(kubectl get pods -n "${JENKINS_NAMESPACE}" --no-headers -o custom-columns=NAME:.metadata.name 2>/dev/null | \
        grep -v "^jenkins-" | wc -l)

    kubectl get pods -n "${JENKINS_NAMESPACE}" --no-headers -o custom-columns=NAME:.metadata.name 2>/dev/null | \
        grep -v "^jenkins-" | \
        xargs -r kubectl delete pod -n "${JENKINS_NAMESPACE}" --force --grace-period=0 >/dev/null 2>&1 || true

    log_info "  Deleted $deleted_pods agent pods"

    # 4. Wait for Jenkins to stabilize
    log_info "Waiting for Jenkins to stabilize..."
    sleep 5
}

# =============================================================================
# Phase 2: Clean up branches and MRs
# =============================================================================
cleanup_local_branches() {
    log_info "Cleaning up local demo branches..."

    local patterns=("uc-*" "update-dev-*" "promote-*" "sync-main-*" "reset-demo-*")
    local deleted=0

    for pattern in "${patterns[@]}"; do
        local branches=$(git branch --list "$pattern" 2>/dev/null | sed 's/^[* ]*//')
        if [[ -n "$branches" ]]; then
            while IFS= read -r branch; do
                if [[ -n "$branch" ]]; then
                    git branch -D "$branch" >/dev/null 2>&1 && deleted=$((deleted + 1))
                fi
            done <<< "$branches"
        fi
    done

    if [[ $deleted -gt 0 ]]; then
        log_info "  Deleted $deleted local demo branches"
    else
        log_info "  No local demo branches to clean"
    fi
}

cleanup_gitlab_orphan_branches() {
    local project_path="$1"
    local gitlab_cli="$SCRIPT_DIR/../04-operations/gitlab-cli.sh"

    log_info "Cleaning up orphaned GitLab demo branches..."

    local patterns=("uc-" "update-dev-" "promote-" "sync-main-" "reset-demo-")
    local deleted=0

    for pattern in "${patterns[@]}"; do
        local branches
        if branches=$("$gitlab_cli" branch list "$project_path" --pattern "${pattern}*" 2>/dev/null); then
            while IFS= read -r branch; do
                if [[ -n "$branch" ]]; then
                    if "$gitlab_cli" branch delete "$project_path" "$branch" >/dev/null 2>&1; then
                        deleted=$((deleted + 1))
                    fi
                fi
            done <<< "$branches"
        fi
    done

    if [[ $deleted -gt 0 ]]; then
        log_info "  Deleted $deleted orphaned GitLab demo branches"
    else
        log_info "  No orphaned GitLab demo branches to clean"
    fi
}

close_all_env_mrs() {
    local project_path="$1"
    local gitlab_cli="$SCRIPT_DIR/../04-operations/gitlab-cli.sh"

    log_info "Closing ALL open MRs targeting environment branches..."

    for target_branch in "${BRANCH_LIST[@]}"; do
        local mr_list
        if ! mr_list=$("$gitlab_cli" mr list "$project_path" --state opened --target "$target_branch" 2>/dev/null); then
            log_info "  $target_branch: no open MRs"
            continue
        fi

        local all_mrs=$(echo "$mr_list" | jq -r '"\(.iid):\(.source_branch)"' 2>/dev/null)

        if [[ -z "$all_mrs" ]]; then
            log_info "  $target_branch: no open MRs"
            continue
        fi

        local count=0
        while IFS=: read -r mr_iid source_branch; do
            if [[ -n "$mr_iid" ]]; then
                log_info "  Closing MR !$mr_iid ($source_branch → $target_branch)..."
                "$gitlab_cli" mr close "$project_path" "$mr_iid" >/dev/null 2>&1 || true

                # Delete source branch if it's not an environment branch
                if [[ "$source_branch" != "dev" && "$source_branch" != "stage" && "$source_branch" != "prod" && "$source_branch" != "main" ]]; then
                    "$gitlab_cli" branch delete "$project_path" "$source_branch" >/dev/null 2>&1 || true
                fi

                count=$((count + 1))
            fi
        done <<< "$all_mrs"

        log_info "  $target_branch: closed $count MRs"
    done
}

# =============================================================================
# Phase 3: Reset CUE Configuration (Baseline Approach)
# =============================================================================

# Extract image tags from current env.cue on a branch
extract_images_from_env_cue() {
    local env="$1"
    local gitlab_cli="$SCRIPT_DIR/../04-operations/gitlab-cli.sh"

    local content=$("$gitlab_cli" file get "$DEPLOYMENTS_REPO_PATH" env.cue --ref "$env" 2>/dev/null)

    # Extract exampleApp image - look for image in the exampleApp block
    # Pattern: after "exampleApp:" find the first "image:" line
    EXAMPLE_APP_IMAGE=$(echo "$content" | awk '
        /exampleApp:.*\{/ { in_example=1 }
        in_example && /image:/ {
            gsub(/.*image:[[:space:]]*"/, "")
            gsub(/".*/, "")
            print
            exit
        }
    ')

    # Extract postgres image - look for image in the postgres block
    POSTGRES_IMAGE=$(echo "$content" | awk '
        /postgres:.*\{/ { in_postgres=1 }
        in_postgres && /image:/ {
            gsub(/.*image:[[:space:]]*"/, "")
            gsub(/".*/, "")
            print
            exit
        }
    ')

    # Fallback to defaults if extraction failed
    if [[ -z "$EXAMPLE_APP_IMAGE" ]]; then
        log_warn "Could not extract exampleApp image from $env, using placeholder"
        EXAMPLE_APP_IMAGE="docker.jmann.local/p2c/example-app:latest"
    fi

    if [[ -z "$POSTGRES_IMAGE" ]]; then
        POSTGRES_IMAGE="postgres:16-alpine"
    fi

    log_info "  exampleApp image: $EXAMPLE_APP_IMAGE"
    log_info "  postgres image: $POSTGRES_IMAGE"
}


# =============================================================================
# Phase 3: Reset CUE Configuration via MR Workflow
# =============================================================================

# Reset a single environment using MR workflow
# Usage: reset_env_via_mr <env>
# This creates a feature branch, commits all reset files, creates MR,
# waits for Jenkins to regenerate manifests, and merges.
reset_env_via_mr() {
    local env="$1"
    local timestamp=$(date +%s)
    local branch_name="reset-demo-${env}-${timestamp}"

    log_info ""
    log_info "=== Resetting $env branch via MR workflow ==="

    # 1. Extract current images (to preserve CI/CD-managed values)
    extract_images_from_env_cue "$env"

    # 2. Gather all files to reset
    local files_to_commit=()

    # 2a. Get services/ files from main
    local encoded_project=$(echo "$DEPLOYMENTS_REPO_PATH" | sed 's/\//%2F/g')
    local tree_url="$GITLAB_URL_EXTERNAL/api/v4/projects/$encoded_project/repository/tree?ref=main&path=services&recursive=true&per_page=100"
    local service_files=$(curl -sk -H "PRIVATE-TOKEN: $GITLAB_TOKEN" "$tree_url" 2>/dev/null | \
        jq -r '.[] | select(.type == "blob") | .path')

    for file_path in $service_files; do
        local content=$(mw_get_file "$DEPLOYMENTS_REPO_PATH" "main" "$file_path")
        if [[ -n "$content" ]]; then
            local content_b64=$(echo "$content" | base64 -w0)
            files_to_commit+=("$file_path:base64:$content_b64")
        fi
    done
    log_info "  Prepared ${#files_to_commit[@]} files from services/"

    # 2b. Get Jenkinsfile from main
    local jenkinsfile_content=$(mw_get_file "$DEPLOYMENTS_REPO_PATH" "main" "Jenkinsfile")
    if [[ -n "$jenkinsfile_content" ]]; then
        local jenkinsfile_b64=$(echo "$jenkinsfile_content" | base64 -w0)
        files_to_commit+=("Jenkinsfile:base64:$jenkinsfile_b64")
        log_info "  Prepared Jenkinsfile"
    fi

    # 2c. Get scripts/ files from main
    tree_url="$GITLAB_URL_EXTERNAL/api/v4/projects/$encoded_project/repository/tree?ref=main&path=scripts&recursive=true&per_page=100"
    local script_files=$(curl -sk -H "PRIVATE-TOKEN: $GITLAB_TOKEN" "$tree_url" 2>/dev/null | \
        jq -r '.[] | select(.type == "blob") | .path')

    local script_count=0
    for file_path in $script_files; do
        local content=$(mw_get_file "$DEPLOYMENTS_REPO_PATH" "main" "$file_path")
        if [[ -n "$content" ]]; then
            local content_b64=$(echo "$content" | base64 -w0)
            files_to_commit+=("$file_path:base64:$content_b64")
            script_count=$((script_count + 1))
        fi
    done
    log_info "  Prepared $script_count files from scripts/"

    # 2d. Generate env.cue from baseline
    local baseline_file="$BASELINES_DIR/env-${env}.cue"
    if [[ -f "$baseline_file" ]]; then
        local env_cue_content=$(cat "$baseline_file" \
            | sed "s|{{EXAMPLE_APP_IMAGE}}|$EXAMPLE_APP_IMAGE|g" \
            | sed "s|{{POSTGRES_IMAGE}}|$POSTGRES_IMAGE|g")
        local env_cue_b64=$(echo "$env_cue_content" | base64 -w0)
        files_to_commit+=("env.cue:base64:$env_cue_b64")
        log_info "  Prepared env.cue from baseline"
    fi

    # 3. Execute MR workflow
    log_info "  Creating feature branch and MR..."

    local title="chore: reset $env to baseline [no-promote]"
    local commit_message="chore: reset $env CUE configuration to baseline [no-promote]

Resets services/, scripts/, Jenkinsfile, and env.cue from main.
Preserves CI/CD-managed image tags.

Automated reset by reset-demo-state.sh"

    if mw_complete_mr_workflow \
        "$DEPLOYMENTS_REPO_PATH" \
        "$env" \
        "$branch_name" \
        "$title" \
        "$commit_message" \
        "${files_to_commit[@]}"; then
        log_info "  ✓ MR !$MW_RESULT_MR_IID merged to $env"
        return 0
    else
        log_error "  ✗ Failed to create/merge MR for $env"
        return 1
    fi
}

# Wait for env branch to be quiescent (no queued or running builds) and verify success
# This is simpler than waiting for a specific NEW build - we just wait for whatever
# is running/queued to finish, then verify the last build succeeded.
# Usage: wait_for_env_quiescence <env> [timeout]
# Returns: 0 if quiescent and last build succeeded, 1 if failed or timeout
wait_for_env_quiescence() {
    local env="$1"
    local timeout="${2:-180}"
    local jenkins_cli="$SCRIPT_DIR/../04-operations/jenkins-cli.sh"
    local start_time=$(date +%s)

    log_info "  Waiting for $env to be quiescent..."

    # Brief delay to allow merge webhook to be processed
    # GitLab webhook → Jenkins → queue the build takes a few seconds
    sleep 5

    while true; do
        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))

        if [[ $elapsed -ge $timeout ]]; then
            log_error "  ✗ Quiescence timeout for $env after ${timeout}s"
            return 1
        fi

        # Check if build is running
        local status_json=$("$jenkins_cli" status "k8s-deployments/$env" 2>/dev/null || echo '{}')
        local building=$(echo "$status_json" | jq -r '.building // false')

        # Check queue for this branch
        local queue_json=$(curl -sk -u "$JENKINS_USER:$JENKINS_TOKEN" \
            "$JENKINS_URL_EXTERNAL/queue/api/json" 2>/dev/null || echo '{"items":[]}')
        local queued=$(echo "$queue_json" | jq -r --arg env "$env" \
            '[.items[] | select(.task.name == $env)] | length')

        if [[ "$building" == "false" ]] && [[ "$queued" == "0" ]]; then
            # Verify the last build succeeded
            local last_result=$(echo "$status_json" | jq -r '.result // empty')
            if [[ "$last_result" != "SUCCESS" ]]; then
                log_error "  ✗ $env build failed (result: $last_result)"
                return 1
            fi
            log_info "  ✓ $env is quiescent (last build: SUCCESS)"
            return 0
        fi

        local status_msg=""
        [[ "$building" == "true" ]] && status_msg="running"
        [[ "$queued" != "0" ]] && status_msg="${status_msg:+$status_msg, }queued"
        log_info "  $env: $status_msg (${elapsed}s elapsed)"

        sleep 10
    done
}

# Main Phase 3 function: Reset all CUE configuration via MR workflow
reset_cue_config() {
    log_step "Phase 3: Resetting CUE configuration via MR workflow..."
    log_info ""
    log_info "This uses the standard MR workflow for each environment:"
    log_info "  feature branch → commit changes → MR → Jenkins CI → merge → quiescence"
    log_info ""

    local failed_envs=()

    for env in "${BRANCH_LIST[@]}"; do
        # Step 1: Create MR and merge (waits for feature branch pipeline)
        if ! reset_env_via_mr "$env"; then
            failed_envs+=("$env")
            continue
        fi

        # Step 2: Wait for pipeline quiescence
        # After merge, webhooks trigger env branch builds. Wait for them to complete
        # so the next demo's preflight check passes (no running/queued builds).
        # This is simpler than tracking specific build timestamps.
        if ! wait_for_env_quiescence "$env" 180; then
            failed_envs+=("$env")
        fi
    done

    if [[ ${#failed_envs[@]} -gt 0 ]]; then
        log_error "Failed to reset environments: ${failed_envs[*]}"
        return 1
    fi

    log_info ""
    log_info "CUE configuration reset complete - all environments verified"
}

# =============================================================================
# Main
# =============================================================================
main() {
    echo "=== Reset Demo State ==="
    echo ""
    echo "This script establishes a well-defined starting point for demos"
    echo "by resetting CUE configuration to canonical baselines."
    echo ""
    echo "CLEAN STARTING POINT:"
    echo "  - Jenkins queue cleared (no stale running/queued jobs)"
    echo "  - No stale local demo branches"
    echo "  - No orphaned GitLab demo branches"
    echo "  - No open MRs targeting dev, stage, or prod branches"
    echo "  - services/ directory reset from main"
    echo "  - env.cue reset to baseline (preserving CI/CD images)"
    echo "  - Manifests regenerated by Jenkins"
    echo ""

    log_step "Credentials loaded via mr-workflow.sh"
    log_info "GitLab: $GITLAB_URL_EXTERNAL"
    log_info "Jenkins: $JENKINS_URL_EXTERNAL"

    # Phase 0: Wait for pipeline quiescence before any cleanup
    # This prevents race conditions with auto-promote webhooks from previous demos
    wait_for_pipeline_quiescence 120

    # Phase 1: Clean up Jenkins
    cleanup_jenkins_queue

    # Phase 2: Clean up branches and MRs
    log_step "Phase 2: Cleaning up branches and MRs..."
    cleanup_local_branches
    close_all_env_mrs "$DEPLOYMENTS_REPO_PATH"
    cleanup_gitlab_orphan_branches "$DEPLOYMENTS_REPO_PATH"

    # Phase 3: Reset CUE configuration
    reset_cue_config

    echo ""
    echo "=== Reset Complete ==="
    echo ""
    log_info "Clean starting point established:"
    log_info "  - Jenkins queue cleared, agent pods deleted"
    log_info "  - Local demo branches cleaned up"
    log_info "  - All env-targeting MRs closed"
    log_info "  - Orphaned GitLab demo branches deleted"
    log_info "  - services/ directory reset from main"
    log_info "  - env.cue reset to baseline (preserving CI/CD images)"
    log_info "  - Manifests regenerated by Jenkins"
    echo ""
    log_info "Next steps:"
    log_info "  1. Commit any local changes: git add -A && git commit -m 'chore: reset demo state'"
    log_info "  2. Push to GitHub: git push origin main"
    log_info "  3. Run validation: ./scripts/test/validate-pipeline.sh"
    log_info "  4. Run demo: ./scripts/demo/demo-uc-c1-default-label.sh"
}

main "$@"
